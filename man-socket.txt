Lors d'acces a une machine, celle-ci se presente a travers une adresse IP permettant son identification.
De nombreux logiciels sont simultanement utilises sur la meme machine. Afin de preciser vers quel logiciel la communication
s'effectue, un socket est attribuer a un logiciel accedant au reseau depuis la machine, agissant comme identifiant supplementaire.
Une socket est simplement un moyen de désigner l’extrémité d’un canal de communication bidirectionnel, côté client ou serveur, 
en l’associant à un port.

Dans le cas du protocol TCP/IP (transmission control protocol / internet protocol)
Un numéro de port comprend 16 bits (0 à 65 535) et est associé à un protocole de transport donné
	(le port TCP n°i et le port UDP n°i )
le port TCP etablie une connexion prealable entre deux hotes, permettant des echange par cette liaison
le port UDP (user datagram protocol) n'est pas prealablement connecter, les echanges s'effectue alors message par message (non utilise pour nous).

le protocol TCP/IP permet alors
	- transmission bidirectionnelle par flot d'octet
	- garatie la fiabilite de l'echange des lors que la liaison physique est cree
	- garantie un flux ordonne (ordre de reception identique a la transmission)
	- Contrôle de flux. Permet au récepteur de limiter le débit d’émission en fonction de ses capacités de réception (entre récepteur et émetteur)
	- Contrôle de congestion. Permet d’agir sur le débit d’émission pour éviter la surcharge du réseau (entre réseau et émetteur)

SERVER SOCKET TCP
Un serveur en mode connecté doit attendre une nouvelle demande de connexion de la part d’un client, 
puis traiter la (ou les requêtes) envoyée(s) sur cette connexion par le client.
Les fonctions d’attente et de traitement sont séparées, pour permettre au serveur d’attendre de nouvelles demandes de 
connexion pendant qu’il traite des requêtes en cours.

La socket serveur est associée à un numéro de port connu des clients (par ex. port 80 pour un serveur web, etc.)
Chaque nouvelle connexion établie par le système d’exploitation du serveur est placée dans la file d’attente.
Si une demande de connexion arrive alors que la file est pleine, elle est rejetée (pourra être réessayée plus tard) -> voir connect()
La socket de communication est creer lors de la demande de connexion d'un client. Elle est associée au même numéro 
de port que la socket serveur, mais avec un descripteur différent

Etape 1 : créer une socket serveur TCP
					ServerSocket servSock = new ServerSocket();
Etape 2.a : associer la socket à une adresse IP et un numéro de port TCP locaux 
					int myPort = …
					InetSocketAddress ipAddrAndPort;
					ipAddrAndPort = new InetSocketAddress(myPort);
					servSock.bind(ipAddrAndPort, …);
Eape 2.b : définir la taille de la file d’attente pour les nouvelles connexions
					int backlogSize = …;
					…
					servSock.bind(ipAddrAndPort, backlogSize);
Etape 3a : permettre à l’application (côté serveur) de prendre connaissance d’une nouvelle connexion
					Socket sock;
					…
					sock = servSock.accept();					==> /!\ la primitive accept est bloquante (si la file est vide)
Etape 3b : obtention d’un canal de communication/dialogue par l’application (côté serveur)
					sock = servSock.accept();					==> au retour de accept() la connexion est supprimee de la file d'attente

CLIENT SOCKET TCP
Ici on connaît l’adresse d’un serveur et le numéro de port (TCP) d’une socket serveur sur celui-ci 
(un processus serveur est en attente sur ce port).

Etape 1 : créer une socket :
					Socket sock = new Socket();
Etape 1 bis : associer la socket à une adresse et/ou un numéro de port (locaux) particuliers (pas toujours necessaire a creer)
					InetSocketAddress localIpAddrAndPort = new InetSocketAddress(…);
					sock.bind(localIpAddrAndPort);
		Choisit un numéro de port libre dans une plage prédéfinie (ports dit « éphémères » ou « dynamiques »)
		Si la machine possède plusieurs adresses IP, associe à la socket l’adresse IP par défaut de la machine
Etape 2 : établir une connexion entre la socket client et le serveur
					InetSocketAddress serverIpAddrAndPort = new InetSocketAddress(…);
					sock.connect(serverIpAddrAndPort);			==> connect envoie une demande de connexion vers la socket serveur
																	(une exceptionIOException est levée en cas d’échec de la connexion)

ECHANGES 
Une fois la connexion établie, le client et le serveur disposent chacun d’un descripteur (pseudo-fichier) 
vers l’extrémité correspondante de la connexion (avec un flux d'entre et de sortie).
Le fonctionnement des flux est similaire au pipe FIFO :	entre client -> sortie server
														entre server -> sortie client
Une lecture sur un flux d’entrée peut être bloquante (si le tampon de réception ne contient pas de nouvelles données),
jusqu’à l’arrivée de nouvelles données envoyées par l’interlocuteur (ou jusqu’à la rupture de la connexion réseau).

VOIR LES SOCKET - command shell
	netstat -t -a --numeric-ports --numeric-hosts
	ss -t
'ss' Options utiles
	-a ou --all : permet d’afficher toutes les sockets existantes sur la machine (par défaut, seules les sockets connectées sont listées)
	-l ou --listening : affiche uniquement les sockets serveurs
	-p : affiche le pid du processus propriétaire d’une socket
	-e : permet de connaître l’utilisateur associé au processus propriétaire d’une socket
	-n ou --numeric : désactiver la résolution des noms de services
	-r ou --resolve : activer la résolution des noms de machines et de services

	port : 16 bits (0 à 65 535) = USHORT
			Les numéros de 0 à 1023 sont réservés, par convention, à des services spécifiques.
			Exemples (avec TCP) :
			7 : echo 	25 : SMTP (acheminement mail) 	443 : HTTPS (HTTP sécurisé)
			22 : SSH 	80 : HTTP (serveur web) 		465 : SMTPS (SMTP sécurisé)
_______________________________________________________________________________________________________________________
socket(7)
#include <sys/socket.h>
sockfd = socket(int famille_socket, int type_socket, int protocole); 


socket(2) crée une socket																					==> <socket()> autorised
connect(2) connecte une socket à une adresse de socket distante												==> <connect()> autorised
bind(2) attache une socket à une adresse local																==> <bind()> autorised
listen(2) indique à la socket que de nouvelles connexions doivent être acceptées							==> <listen()> autorised
accept(2) fournit une nouvelle socket avec la nouvelle connexion entrante. 									==> <accept()> autorised
socketpair(2) renvoie deux sockets anonymes connectées (seulement implémenté pour quelques familles locales comme AF_UNIX).

send(2), sendto(2), et sendmsg(2) envoient des données sur une socket										==> <send()> autorised
recv(2), recvfrom(2) et recvmsg(2) reçoivent les données envoyées par une socket							==> <recv()> autorised
poll(2) et select(2) attendent que des données arrivent ou que l'émission soit possible. 					==> <poll()> or <select()> autorised

De plus, les opérations d'entrée-sortie standard comme write(2), writev(2), sendfile(2), read(2) et readv(2)
peuvent être utilisées pour la lecture et l'écriture des données.

getsockname(2) renvoie l'adresse de la socket locale														==> <getsockname()> aurotised
getpeername(2) renvoie l'adresse de la socket distante. 
getsockopt(2) et setsockopt(2) servent à définir et obtenir les options de la couche socket ou protocole. 	==> <setsockopt()> autorised
ioctl(2) peut être utilisé pour lire et écrire d'autres options.

close(2) sert à fermer une socket. shutdown(2) ferme une partie des connexions d'une socket multiple.		==> <close()> autorised

La recherche ou l'utilisation de pread(2) et pwrite(2) avec un décalage non nul n'est pas possible sur les sockets.

Des opérations d'entrée-sortie non bloquantes sur les sockets sont possibles en définissant 
l'attribut O_NONBLOCK du descripteur de la socket avec fcntl(2). Toutes les opérations qui 					==> /!\ memoire --> use <poll()>
devraient normalement bloquer se terminent alors avec l'erreur EAGAIN (l'opération devra être 
retentée ultérieurement). 
connect(2) renverra l'erreur EINPROGRESS. L'utilisateur peut alors attendre divers événements avec poll(2) ou select(2).
			Événements E/S
Événement		Appel		Circonstance
Lecture			POLLIN		Arrivée de nouvelles données
Lecture			POLLIN		Configuration d'une connexion achevée (pour les sockets orientées connexion)
Lecture			POLLHUP		Demande de déconnexion initiée par l'autre extrémité
Lecture			POLLHUP		Connexion rompue (seulement pour les protocoles orientés connexion) 
								Lors de l'écriture sur la socket, le signal SIGPIPE est aussi émis.
Écriture		POLLOUT		La socket a assez de place dans le tampon d'émission pour écrire de nouvelles données.
Lect./Écrit.	POLLIN|
				POLLOUT 	Un appel sortant à connect(2) est terminé.
Lect./Écrit.	POLLERR		Une erreur asynchrone s'est produite.
Lect./Écrit.	POLLHUP		Le correspondant a clos un sens de communication.
Exception		POLLPRI		Arrivée de données urgentes. SIGURG est alors envoyé.

Une alternative à poll(2) et select(2) est de laisser le noyau informer l'application des événements par 
l'intermédiaire d'un signal SIGIO. Pour cela, l'attribut O_ASYNC doit être défini sur un descripteur de fichier 
de la socket via fcntl(2) et un gestionnaire de signal valable pour SIGIO doit être installé avec sigaction(2). 
Consultez les remarques sur les Signaux ci-dessous.

Structures d'adresse de socket
Chaque domaine de socket a son propre format pour les adresses de socket, avec une structure d'adresse propre. 
Chacune de ces structures commence avec un champ entier « family » (famille), de type sa_family_t, qui indique 
le type de structure d'adresse. Cela permet aux appels système génériques à tous les domaines de sockets 
(par exemple connect(2), bind(2), accept(2), getsockname(2), getpeername(2)) de déterminer le domaine d'une adresse de socket donnée.

Le type struct sockaddr est défini afin de pouvoir passer n'importe quel type d'adresse de socket aux interface 
dans l'API des sockets. Le but de ce type est purement d'autoriser la conversion de types d'adresse de socket propres 
à un domaine vers le type « générique », afin d'éviter les avertissements du compilateur au sujet de la non 
correspondance dans les appels de l'API des sockets.

De plus, l'API des sockets fournit le type de données struct sockaddr_storage. Ce type est fait pour contenir toute 
structure d'adresse de socket spécifique à un domaine. Il est suffisamment grand et est aligné correctement 
(en particulier, il est assez grand pour contenir des adresses de socket IPv6). 
Cette structure contient le champ suivant, qui peut être utilisé pour identifier le type d'adresse socket 
effectivement stockée dans la structure :

    sa_family_t ss_family;

La structure sockaddr_storage est utile dans les programmes qui doivent prendre en charge les adresses de socket 
de manière générique (par exemple les programmes qui doivent gérer à la fois des adresses de socket IPv4 et IPv6).

Options de sockets
Les options présentées ci-dessous peuvent être définies en utilisant setsockopt(2) et lues avec getsockopt(2) 
avec le niveau de socket positionné à SOL_SOCKET, et ce pour toutes les sockets. 
Sauf mention contraire, optval est un pointeur vers un int.

SO_ACCEPTCONN																										==> peut etre utile en debug
    Renvoie une valeur indiquant si la socket a été déclarée comme acceptant les connexions à l'aide de listen(2). 
	La valeur 0 indique que la socket n'est pas en attente de connexions et la valeur 1 indique que la socket 
	accepte les connexions. Cette option de socket peut être seulement lue, et pas modifiée. 
SO_BINDTODEVICE
    Attache cette socket à un périphérique donné, tel que « eth0 », comme indiqué dans le nom d'interface transmis. 
	Si le nom est une chaîne vide ou si la longueur de l'option est nulle, la socket est détachée du périphérique. 
	L'option transmise est une chaîne de longueur variable terminée par un caractère nul, contenant le nom de 
	l'interface, la longueur maximale étant IFNAMSIZ. Si une socket est attachée à une interface, seuls les paquets 
	reçus de cette interface particulière sont traités par la socket. Cela ne fonctionne que pour certains types de 
	sockets, en particulier les sockets AF_INET. Ce n'est pas géré pour les sockets paquet (utilisez pour cela bind(2)).

    Avant Linux 3.8, cette option de socket pouvait être configurée, sans pouvoir être lue par getsockopt(2). 
	Depuis Linux 3.8, elle est lisible. Le paramètre optlen doit contenir la taille du tampon destiné à recevoir le nom 
	du périphérique, préférablement IFNAMSZ. La véritable longueur du nom du périphérique est renvoyée dans le paramètre optlen. 
SO_BROADCAST
    Définir ou lire l'attribut de diffusion. Une fois activé, les sockets de datagrammes sont autorisées à envoyer 
	des paquets à une adresse de diffusion. Cette option n'a aucun effet sur les sockets orientées flux. 
SO_BSDCOMPAT
    Active la compatibilité BSD bogue-à-bogue. Cela est utilisé par le module du protocole UDP de Linux 2.0 et 2.2. 
	Si cette compatibilité est activée, les erreurs ICMP reçues pour une socket UDP ne seront pas transmises au 
	programme utilisateur. Dans les versions récentes du noyau, la gestion de cette option a été abandonnée 
	progressivement : Linux 2.4 l'ignore silencieusement et Linux 2.6 génère une alerte noyau (printk()) si le 
	programme utilise cette option. Linux 2.0 activait également les options de compatibilité BSD bogue-à-bogue 
	(modification aléatoire des en-têtes, non prise en compte de l'attribut de diffusion) pour les sockets brutes 
	ayant cette option, mais cela a été éliminé dans Linux 2.2. 
SO_DEBUG
    Active le débogage de socket. Cela n'est autorisé que pour les processus avec la capacité CAP_NET_ADMIN ou un 
	identifiant d'utilisateur effectif égal à 0. 
SO_DOMAIN (depuis Linux 2.6.32)
    Récupère le domaine de socket en tant qu'entier, en renvoyant une valeur telle que AF_INET6. 
	Consultez socket(2) pour plus de détails. Cette option de socket peut être seulement lue, et pas modifiée. 
SO_ERROR
	Lit et efface l'erreur en cours sur la socket. Cette option de socket peut être seulement lue, et pas modifiée.
	Demande un entier. 
SO_DONTROUTE
    Ne pas émettre par l'intermédiaire d'une passerelle, n'envoyer qu'aux hôtes directement connectés. 
	Le même effet peut être obtenu avec l'attribut MSG_DONTROUTE durant une opération send(2) sur la socket. 
	Demande un attribut entier booléen. 
SO_KEEPALIVE
    Active l'émission de messages périodiques gardant la socket ouverte pour les sockets orientées connexion. 
	Demande un attribut entier booléen. 
SO_LINGER
    Définit ou lit l'option SO_LINGER. Le paramètre est une structure linger.

    struct linger {
        int l_onoff;    /* définition de l'activité */
        int l_linger;   /* durée d'attente en secondes */
    };

    Lorsque ce paramètre est actif, un appel à close(2) ou shutdown(2) ne se terminera pas avant que tous les 
	messages en attente pour la socket aient été correctement émis ou que le délai d'attente soit écoulé. 
	Sinon, l'appel se termine immédiatement et la fermeture est effectuée en arrière-plan. Lorsque la socket 
	est fermée au cours d'un exit(2), elle attend toujours en arrière-plan. 
SO_MARK (depuis Linux 2.6.25)
    Positionner la marque pour chaque paquet envoyé au travers de cette socket (similaire à la cible MARK de 
	netfilter, mais pour les sockets). Le changement de marque peut être utilisé pour un routage par marques 
	sans netfilter ou pour le filtrage de paquets. Utiliser cette option nécessite la capacité CAP_NET_ADMIN. 
SO_OOBINLINE
    Si cette option est activée, les données hors bande sont placées directement dans le flux des données reçues. 
	Sinon, elles ne sont transmises que si l'attribut MSG_OOB est défini durant la réception. 
SO_PASSCRED
    Autorise ou interdit la réception des messages de contrôle SCM_CREDENTIALS. 
	Pour plus de détails, consultez unix(7). 
SO_PEEK_OFF (depuis Linux 3.4)
    Cette option, qui n'est à ce jour garantie que pour les sockets unix(7), définit la valeur de la 
	« position de lecture » (ou « peek offset ») pour l'appel système recv(2) lorsqu'il est invoqué avec l'attribut MSG_PEEK.

    Lorsque cette option reçoit une valeur négative (elle est initialisée à -1 pour toute nouvelle socket), 
	elle se comporte classiquement : recv(2), avec l'attribut MSG_PEEK, lit les données depuis le début de la file.

    Lorsque l'option reçoit une valeur supérieure ou égale à zéro, alors la lecture suivante des données accumulées 
	dans la socket est réalisée à la position précisée par la valeur de l'option. Dans le même temps, la 
	« position de lecture » est incrémentée du nombre d'octets lus dans la file, de façon à ce que la prochaine 
	lecture renvoie la donnée suivante dans la file.

    Si des données sont retirées de la tête de la file par la fonction recv(2) (ou équivalent) sans l'attribut MSG_PEEK, 
	alors la « position de lecture » est diminuée du nombre d'octets supprimés. Autrement dit, l'acquisition de données 
	sans avoir recours à l'attribut MSG_PEEK a pour effet de modifier la « position de lecture », de sorte que la prochaine 
	lecture renvoie les données qui auraient été renvoyées si aucune donnée n'avait été supprimée.

    Pour les sockets de datagrammes, si la « position de lecture » pointe à l'intérieur d'un paquet, alors les données 
	renvoyées seront marquées de l'attribut MSG_TRUNC.

    L'exemple suivant illustre l'usage de SO_PEEK_OFF. Imaginons une socket de flux contenant les données suivantes dans sa file :


        aabbccddeeff

    La séquence suivante d'appels à recv(2) aura l'effet décrit dans les commentaires :

    int ov = 4;                  // affecte 4 à la position de lecture
    setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));
    recv(fd, buf, 2, MSG_PEEK);  // Lit "cc"; l'indide de position prend la valeur 6
    recv(fd, buf, 2, MSG_PEEK);  // Lit "dd"; l'indice de position prend la valeur 8
    recv(fd, buf, 2, 0);         // Lit "aa"; l'indice de position prend la valeur 6
    recv(fd, buf, 2, MSG_PEEK);  // Lit "ee"; l'indice position prend la valeur 8

SO_PEERCRED
    Renvoie les données d'authentification du processus étranger connecté à cette socket. Cela n'est possible 
	que pour les sockets de flux AF_UNIX connectées et les paires de sockets AF_UNIX de flux et de datagrammes 
	crées avec socketpair(2) ; consultez unix(7). Les données retournées sont celles qui étaient effectives au 
	moment de l'appel à connect(2) ou socketpair(2). L'argument est une structure ucred. Il faut définir la macro 
	de test de fonctionnalité _GNU_SOURCE pour activer la définition de cette structure dans <sys/socket.h>. 
	Cette option de socket peut être seulement lue, et pas modifiée. 
SO_PRIORITY
    Définir la priorité définie par le protocole pour tous les paquets envoyés sur la socket. Linux utilise cette 
	valeur pour trier les files réseau : les paquets avec une priorité élevée peuvent être traités d'abord, en 
	fonction de la gestion des files sur le périphérique. Pour ip(7), cela définit aussi le champ 
	IP Type-Of-Service (TOS) pour les paquets sortants. 
	Établir une priorité en dehors de l'intervalle allant de 0 à 6 nécessite la capacité CAP_NET_ADMIN. 
SO_PROTOCOL (depuis Linux 2.6.32)																					==> peut etre utile debug
    Récupère le protocole de socket en tant qu'entier, en renvoyant une valeur telle que IPPROTO_SCTP. 
	Consultez socket(2) pour plus de détails. Cette option de socket peut être seulement lue, et pas modifiée. 
SO_RCVBUF
    Définit ou lit la taille maximale en octets du tampon de réception. Le noyau double cette valeur (pour 
	prévoir de l'espace pour les opérations de service) lorsque la valeur est définie avec setsockopt(2), et 
	cette valeur doublée est retournée par getsockopt(2). 
	La valeur par défaut est définie par le fichier /proc/sys/net/core/rmem_default 
	et la valeur maximale autorisée est définie par le fichier /proc/sys/net/core/rmem_max. 
	La valeur (doublée) minimale pour cette option est 256. 
SO_RCVBUFFORCE (depuis Linux 2.6.14)
    En utilisant cette option de socket, un processus privilégié (CAP_NET_ADMIN) peut exécuter la même tâche que 
	SO_RCVBUF, mais la limite rmem_max peut être remplacée. 
SO_RCVLOWAT et SO_SNDLOWAT
    Indique le nombre minimal d'octets dans le tampon pour que la couche socket passe les données au protocole 
	(SO_SNDLOWAT) ou à l'utilisateur en réception (SO_RCVLOWAT). Ces deux valeurs sont initialisées à 1. 
	SO_SNDLOWAT n'est pas modifiable (setsockopt(2) échoue avec l'erreur ENOPROTOOPT). SO_RCVLOWAT est 
	modifiable seulement depuis Linux 2.4. Les appels système select(2) et poll(2) ne respectent pour le moment 
	pas la définition de SO_RCVLOWAT sur Linux, et marque la socket comme lisible même lorsqu'un unique octet de 
	données est disponible. La lecture suivante depuis la socket sera bloquée jusqu'à ce que SO_RCVLOWAT octets soient disponibles. 
SO_RCVTIMEO et SO_SNDTIMEO																							==> reperer erreur flux connexion
    Indiquer le délai maximal d'émission ou de réception avant de signaler une erreur. 
	Le paramètre est une structure timeval. Si une fonction d'entrée ou de sortie bloque pendant cet intervalle de 
	temps et que des données ont été envoyées ou reçues, la valeur de retour de cette fonction sera la quantité de 
	données transmises ; si aucune donnée n'a été transmise et si le délai d'attente est atteint, -1 est renvoyé et 
	errno est positionnée à EAGAIN ou EWOULDBLOCK, ou EINPROGRESS (pour connect(2)), comme si la socket avait été 
	définie comme non bloquante. Si le délai d'attente est défini à zéro (valeur par défaut), l'opération ne sera 
	jamais interrompue. Les délais n'ont d'effet que pour les appels système faisant des E/S sur des sockets 
	(par exemple read(2), recvmsg(2), send(2), sendmsg(2)) ; ils n'ont pas d'effet pour select(2), poll(2), epoll_wait(2), etc. 
SO_REUSEADDR
    Indique que les règles utilisées pour la validation des adresses fournies dans un appel à bind(2) doivent 
	autoriser la réutilisation des adresses locales. Pour les sockets AF_INET, cela signifie que la socket peut 
	être attachée à n'importe quelle adresse sauf lorsqu'une socket active en écoute y est liée. 
	Lorsque la socket en écoute est attachée à INADDR_ANY avec un port spécifique, il n'est pas possible de 
	s'attacher à ce port quelle que soit l'adresse locale. L'argument est un attribut booléen entier. 
SO_RXQ_OVFL (depuis Linux 2.6.33)
    Indique qu'un message auxiliaire (cmsg) sous la forme d'une valeur non-signée et codée sur 32 bits doit
	être jointe aux tampons de sockets (skbs), indiquant le nombre de paquets perdus par la socket entre les 
	deux derniers paquets reçus. 
SO_SNDBUF
    Définit ou lit la taille maximale en octets du tampon d'émission. Le noyau double cette valeur (pour prévoir 
	de l'espace pour les opérations de service) lorsque la valeur est définie avec setsockopt(2), et cette valeur 
	doublée est retournée par getsockopt(2). 
	La valeur par défaut est définie par le fichier /proc/sys/net/core/wmem_default 
	et la valeur maximale autorisée est définie par le fichier /proc/sys/net/core/wmem_max. 
	La valeur (doublée) minimale pour cette option est 2048. 
SO_SNDBUFFORCE (depuis Linux 2.6.14)
    En utilisant cette option de socket, un processus privilégié (CAP_NET_ADMIN) peut exécuter la même tâche que 
	SO_SNDBUF, mais la limite wmem_max peut être remplacée. 
SO_TIMESTAMP
    Active ou désactive la réception des messages de contrôle SO_TIMESTAMP. Le message de contrôle d'horodatage 
	est envoyé avec le niveau SOL_SOCKET et le champ cmsg_data est une structure timeval indiquant la date de 
	réception du dernier paquet fourni à l'utilisateur dans cet appel. 
	Consultez cmsg(3) pour plus de détails sur les messages de contrôle. 
SO_TYPE
    Lit le type de socket, sous forme d'entier (comme SOCK_STREAM). 
	Cette option de socket peut être seulement lue, et pas modifiée. 
SO_BUSY_POLL (depuis Linux 3.11)
    Définit la durée approximative, en milliseconde, d’attente active de réception bloquante en absence de données. 
	CAP_NET_ADMIN est nécessaire pour augmenter cette valeur. La valeur par défaut pour cette option est contrôlée 
	par le fichier /proc/sys/net/core/busy_read.

    La valeur dans le fichier /proc/sys/net/core/busy_poll détermine la durée pendant laquelle select(2) et poll(2)
	seront en attente active lors d’une opération sur des sockets avec SO_BUSY_POLL défini et qu’aucun événement à
	signaler n’est trouvé.

    Dans les deux cas, l’attente active ne sera réalisée que lorsque les dernières données reçues par la socket 
	proviennent d’un périphérique réseau qui ne prend pas en charge cette option.

    Bien que l’attente active peut améliorer la latence de quelques applications, une attention particulière doit 
	être portées à son utilisation puisque cela augmentera à la fois l’utilisation du processeur et la consommation puissance. 


Signaux
Lors de l'écriture sur une socket orientée connexion qui a été fermée (localement ou à l'autre extrémité), 			==> /!\
le signal SIGPIPE est envoyé au processus qui écrivait, et EPIPE est renvoyé. 
Le signal n'est pas envoyé lorsque l'appel d'écriture indiqué contenait l'attribut MSG_NOSIGNAL.

Lorsque demandé avec l'option FIOSETOWN de fcntl(2) ou l'option SIOCSPGRP de ioctl(2), le signal SIGIO est 
envoyé quand un événement d'entrée-sortie a lieu. Il est possible d'utiliser poll(2) ou select(2) dans le 
gestionnaire de signal pour savoir sur quelle socket l'événement s'est produit. Une alternative 
(sous Linux 2.2) est de définir un signal en temps-réel avec le fnctl(2) F_SETSIG. Le gestionnaire du 
signal en temps-réel sera appelé avec le descripteur de fichier dans le champ si_fd de siginfo_t. 
Consultez fcntl(2) pour plus d'informations.

Dans certains cas (par exemple, différents processus accédant à la même socket), la condition ayant déclenché 
le signal SIGIO peut avoir déjà disparu quand le processus réagit au signal. Si cela se produit, le processus 
devrait attendre à nouveau car Linux renverra ce signal ultérieurement.


Interfaces /proc
Les paramètres réseau de base des sockets sont accessibles en utilisant les fichiers du répertoire /proc/sys/net/core/.

rmem_default
    contient la taille en octets par défaut du tampon de réception. 
rmem_max
    contient la taille maximale en octets du tampon de réception qu'un utilisateur peut définir avec l'option SO_RCVBUF de la socket. 
wmem_default
    contient la taille en octets par défaut du tampon d'émission de la socket. 
wmem_max
    contient la taille maximale en octets du tampon d'émission qu'un utilisateur peut définir avec l'option SO_SNDBUF de la socket. 
message_cost et message_burst
    configurent le filtrage par jeton utilisé pour limiter la charge des messages d'avertissement dus aux événements réseau extérieurs. 
netdev_max_backlog
    contient le nombre maximal de paquets dans la file d'entrée globale. 
optmem_max
    contient la taille maximale par socket des données de service et des données de contrôle utilisateur comme les iovecs. 


Ioctls
Ces opérations sont accessibles en utilisant ioctl(2) :

error = ioctl(ip_socket, type_ioctl, &valeur_résultat);

SIOCGSTAMP
    Renvoie une structure timeval avec la date de réception du dernier paquet transmis à l'utilisateur. 
	Cela est utile pour des mesures précises du temps de cheminement. Consultez setitimer(2) pour une 
	description de la structure timeval. L'ioctl ne doit être utilisé que si l'option SO_TIMESTAMP de la 
	socket n'est pas définie. Sinon, la date du dernier paquet reçu quand SO_TIMESTAMP n'était pas définie 
	est renvoyée, provoquant un échec s'il n'existe pas de tels paquets (c'est-à-dire que ioctl(2) 
	renvoie -1 avec un errno défini à ENOENT). 
SIOCSPGRP
    Définit le processus ou le groupe de processus à qui envoyer les signaux SIGIO ou SIGURG lorsqu'une 
	opération d'entrée-sortie asynchrone est terminée ou si des données urgentes sont disponibles. 
	L'argument est un pointeur sur un pid_t. Si l'argument est positif, le signal est envoyé à ce processus. 
	S'il est négatif, le signal est envoyé au groupe de processus dont l'identifiant correspond à la valeur 
	absolue de l'argument. Un processus ne peut demander que l'émission vers lui-même ou son propre groupe, à 
	moins qu'il ait la capacité CAP_KILL ou un identifiant d'utilisateur effectif nul. 
FIOASYNC
    Change l'attribut O_ASYNC pour activer ou désactiver le mode d'entrée-sortie asynchrone de la socket. 
	Un mode d'entrée-sortie asynchrone signifie que le signal SIGIO ou le signal défini avec F_SETSIG est 
	envoyé quand un événement d'entrée-sortie se produit. 
    Le paramètre est un booléen entier. (Cette opération est synonyme de l'utilisation de fcntl(2) pour définir l'attribut O_ASYNC). 
SIOCGPGRP
    Lit le processus ou le groupe de processus auquel les signaux SIGIO ou SIGURG sont envoyés. 
	Zéro est obtenu quand aucun n'est défini. 


Opérations fcntl(2) valables :

FIOGETOWN
    Identique à l'ioctl(2) SIOCGPGRP. 
FIOSETOWN
    Identique à l'ioctl(2) SIOCSPGRP. 

VERSIONS
SO_BINDTODEVICE a été introduit dans Linux 2.0.30. SO_PASSCRED est une nouveauté de Linux 2.2. 
Les interfaces /proc ont été introduites dans Linux 2.2. SO_RCVTIMEO et SO_SNDTIMEO sont gérés depuis Linux 2.3.41. 
Auparavant, les délais d'attente étaient définis dans les protocoles et ne pouvaient être ni lus ni modifiés.

NOTES
Linux suppose que la moitié du tampon d'émission/réception est utilisé pour les structures internes du noyau. 
Ainsi les valeurs dans les fichiers /proc correspondants sont deux fois plus grandes que ce que l'on peut 
observer directement sur le câble.

Linux ne permettra la réutilisation des ports qu'avec l'option SO_REUSEADDR lorsque celle-ci sera définie 
à la fois par le précédent programme qui a effectué un bind(2) sur le port et par le programme qui veut 
réutiliser ce port. Ceci diffère de certaines implémentations (par exemple, sur FreeBSD) où seul le dernier 
programme doit définir l'option SO_REUSEADDR. Habituellement, cette différence est invisible, puisque, par exemple, 
un programme serveur est conçu pour toujours définir cette option. 

_______________________________________________________________________________________________________________________

SOCKET
	#include <sys/types.h> /* See NOTES */
	#include <sys/socket.h>

	int socket(int domain, int type, int protocol);

	The DOMAIN argument specifies a communication domain; this selects the protocol family
	which will be used for communication. These families are defined in <sys/socket.h>.
	The currently understood formats include: 
		AF_INET 	IPv4 Internet protocols 	ip(7)
		AF_INET6 	IPv6 Internet protocols 	ipv6(7)

	The socket has the indicated TYPE, which specifies the communication semantics.
	Currently defined types are: 
		SOCK_STREAM
			Provides sequenced, reliable, two-way, connection-based byte streams.
			An out-of-band data transmission mechanism may be supported. 
		SOCK_DGRAM
			Supports datagrams (connectionless, unreliable messages of a fixed maximum length). 
		SOCK_SEQPACKET
			Provides a sequenced, reliable, two-way connection-based data transmission path for
			datagrams of fixed maximum length; a consumer is required to read an entire packet
			with each input system call. 
		SOCK_RAW
			Provides raw network protocol access. 
		SOCK_RDM
			Provides a reliable datagram layer that does not guarantee ordering. 
		SOCK_PACKET
			Obsolete and should not be used in new programs; see packet(7).
	Some socket types may not be implemented by all protocol families;
	for example, SOCK_SEQPACKET is not implemented for AF_INET.

	Since Linux 2.6.27, the type argument serves a second purpose: in addition to specifying a
	socket type, it may include the bitwise OR of any of the following values,
	to modify the behavior of socket():
		SOCK_NONBLOCK
			Set the O_NONBLOCK file status flag on the new open file description.
			Using this flag saves extra calls to fcntl(2) to achieve the same result. 												<== <fcntl> autorised
		SOCK_CLOEXEC
			Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.
			See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.

	The protocol specifies a particular protocol to be used with the socket.
	Normally only a single protocol exists to support a particular socket type within a given protocol family,
	in which case protocol can be specified as 0. However, it is possible that many protocols may exist,
	in which case a particular protocol must be specified in this manner.
	The protocol number to use is specific to the 'communication domain' in which communication is to take place;
	see protocols(5).																												<-- protocol.txt
	See getprotoent(3) on how to map protocol name strings to protocol numbers.

	Sockets of type SOCK_STREAM are full-duplex byte streams, similar to pipes.\
		( https://web.maths.unsw.edu.au/~lafaye/CCM/transmission/transmode.htm )
	They do not preserve record boundaries. A stream socket must be in a connected state before any
	data may be sent or received on it. A connection to another socket is created with a connect(2) call. 							<== <connect> autorised
	Once connected, data may be transferred using read(2) and write(2) calls or some variant of the send(2) and recv(2) calls.		<== <recv> autorised
	When a session has been completed a close(2) may be performed.																	<== <close> autorised
	Out-of-band data may also be transmitted as described in send(2) and received as described in recv(2).							<== <send> autorised

	The communications protocols which implement a SOCK_STREAM ensure that data is not lost or duplicated.							<== reception control
	If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted
	within a reasonable length of time, then the connection is considered to be dead.
	When SO_KEEPALIVE is enabled on the socket the protocol checks in a protocol-specific manner if the other end is still alive.
	A SIGPIPE signal is raised if a process sends or receives on a broken stream;													<== signal
	this causes naive processes, which do not handle the signal, to exit.
	SOCK_SEQPACKET sockets employ the same system calls as SOCK_STREAM sockets.
	The only difference is that read(2) calls will return only the amount of data requested,
	and any data remaining in the arriving packet will be discarded.
	Also all message boundaries in incoming datagrams are preserved.

	SOCK_DGRAM and SOCK_RAW sockets allow sending of datagrams to correspondents named in sendto(2) calls.
	Datagrams are generally received with recvfrom(2), which returns the next datagram along with the address of its sender.

	SOCK_PACKET is an obsolete socket type to receive raw packets directly from the device driver. Use packet(7) instead.

	An fcntl(2) F_SETOWN operation can be used to specify a process or process group to receive a SIGURG signal 					<== <fcntl> autorised
	when the out-of-band data arrives or SIGPIPE signal when a SOCK_STREAM connection breaks unexpectedly. 							<== signal
	This operation may also be used to set the process or process group that receives the I/O and asynchronous notification 
	of I/O events via SIGIO. Using F_SETOWN is equivalent to an ioctl(2) call with the FIOSETOWN or SIOCSPGRP argument.

	When the network signals an error condition to the protocol module 
	(e.g., using a ICMP message for IP) the pending error flag is set for the socket. 
	The next operation on this socket will return the error code of the pending error. 
	For some protocols it is possible to enable a per-socket error queue to retrieve detailed information about the error; 
	see IP_RECVERR in ip(7).

	The operation of sockets is controlled by socket level options. These options are defined in <sys/socket.h>. 
	The functions setsockopt(2) and getsockopt(2) are used to set and get options, respectively.									<== <setsockopt> autorised
	
	Return Value
	On success, a file descriptor for the new socket is returned. On error, -1 is returned, and errno is set appropriately.
	Errors
		EACCES
			Permission to create a socket of the specified type and/or protocol is denied. 
		EAFNOSUPPORT
			The implementation does not support the specified address family. 
		EINVAL
			Unknown protocol, or protocol family not available. 
		EINVAL
			Invalid flags in type. 
		EMFILE
			Process file table overflow. 
		ENFILE
			The system limit on the total number of open files has been reached. 
		ENOBUFS or ENOMEM
			Insufficient memory is available. The socket cannot be created until sufficient resources are freed. 
		EPROTONOSUPPORT
			The protocol type or the specified protocol is not supported within this domain.

	Other errors may be generated by the underlying protocol modules.
	Conforming to
		4.4BSD, POSIX.1-2001.

	The SOCK_NONBLOCK and SOCK_CLOEXEC flags are Linux-specific.

	socket() appeared in 4.2BSD. 
	It is generally portable to/from non-BSD systems supporting clones of the BSD socket layer (including System V variants).

	Notes
	POSIX.1-2001 does not require the inclusion of <sys/types.h>, and this header file is not required on Linux. 
	However, some historical (BSD) implementations required this header file, 
	and portable applications are probably wise to include it.

	The manifest constants used under 4.x BSD for protocol families are PF_UNIX, PF_INET, 
	and so on, while AF_UNIX, AF_INET, and so on are used for address families. 
	However, already the BSD man page promises: "The protocol family generally is the same as the address family", 
	and subsequent standards use AF_* everywhere. 
_______________________________________________________________________________________________________________________

SETSOCKOPT
 setsockopt(2) - Lire et écrire les options d'une socket

#include <sys/types.h> /* Consultez NOTES */
#include <sys/socket.h>

int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);

DESCRIPTION
getsockopt() et setsockopt() manipulent les options associées à la socket à laquelle fait référence le descripteur 
de fichier sockfd. Ces options peuvent exister aux divers niveaux de protocole, et sont toujours présentes 
au niveau socket le plus élevé.

Quand on manipule une option d'une socket, il faut préciser le niveau où elle s'applique, et le nom de l'option. 
Au niveau de l'API des sockets, level prend la valeur SOL_SOCKET. Pour tous les autres niveaux, il faut fournir 
le numéro de protocole approprié. Par exemple, pour une option interprétée par le protocole TCP, level prendra le 
numéro du protocole TCP. Consultez getprotoent(3).																			<-- protocol.txt

Les paramètres optval et optlen sont utilisés pour déterminer les options pour setsockopt(). Pour getsockopt 
ils identifient un tampon dans lequel la valeur de l'option désirée doit être renvoyée. Pour getsockopt, 
optlen est un paramètre résultat, contenant initialement la taille du tampon pointé par optval, et rempli en retour 
pour indiquer la taille effective des valeurs renvoyées. Si aucune option n'est fournie ou renvoyée, optval peut être NULL.

optname et toute autre option sont passés sans interprétation au protocole approprié, pour qu'il l'interprète lui-même. 
Le fichier d'en-tête <sys/socket.h> contient les définitions pour le niveau socket. Les options pour les autres niveaux 
de protocole peuvent varier tant en format qu'en nom, consultez les pages de manuel de la section 7 pour plus d'informations.

La plupart des options au niveau socket utilisent un paramètre de type int pour optval. 
Pour setsockopt(), un paramètre non nul valide une option booléenne, et zéro l'invalide.									<== /!\

Pour une description des options disponibles consultez socket(7) et les pages correspondant au protocole concerné.
VALEUR RENVOYÉE
S'il réussit, cet appel système renvoie 0. S'il échoue, il renvoie -1 et remplit errno en conséquence.
ERREURS
	EBADF
		sockfd n'est pas un descripteur valable. 
	EFAULT
		optval pointe en dehors de l'espace d'adressage accessible. Avec getsockopt(), ceci peut s'appliquer également à optlen. 
	EINVAL
		optlen non valable pour setsockopt(). Dans certains cas cette erreur peut aussi se produire pour une valeur 
		non valable de optval (par exemple, pour l'option IP_ADD_MEMBERSHIP décrite dans ip(7)). 
	ENOPROTOOPT
		L'option est inconnue pour ce protocole. 
	ENOTSOCK
		Le paramètre sockfd est un fichier, pas une socket. 

CONFORMITÉ
SVr4, BSD 4.4 (ces appels système sont apparus dans BSD 4.2), POSIX.1-2001.
NOTES
POSIX.1-2001 ne requiert pas l'inclusion de <sys/types.h>, et cet en-tête n'est pas nécessaire sous Linux. 
Cependant, il doit être inclus sous certaines implémentations historiques (BSD), et les applications portables 
devraient probablement l'utiliser.

Le paramètre optlen de getsockopt() et setsockopt() est en fait un int [*] (et c'est ce qu'utilisent BSD 4.x, libc4 et libc5). 
Une certaine confusion POSIX a donné le socklen_t actuel, également utilisé par glibc. Pour plus de détails consultez accept(2). 

_______________________________________________________________________________________________________________________
       #include <sys/socket.h>

       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */									==> unsigned int type defined by <sys/socket.h>
           char            sa_data[];      /* Socket address */
       };

																								==> socklen_t – an unsigned opaque integer type of length of at least 32-bits.
_______________________________________________________________________________________________________________________

GETSOCKNAME
getsockname(2)
NAME
       getsockname - get socket name

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <sys/socket.h>

       int getsockname(int sockfd, struct sockaddr *restrict addr,
                       socklen_t *restrict addrlen);

DESCRIPTION
       getsockname() returns the current address to which the socket sockfd is bound, in the buffer pointed to by addr.  The addrlen ar‐
       gument should be initialized to indicate the amount of space (in bytes) pointed to by addr.  On return  it  contains  the  actual
       size of the socket address.

       The returned address is truncated if the buffer provided is too small; in this case, addrlen will return a value greater than was
       supplied to the call.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set to indicate the error.

ERRORS
       EBADF  	The argument sockfd is not a valid file descriptor.
       EFAULT	The addr argument points to memory not in a valid part of the process address space.
       EINVAL 	addrlen is invalid (e.g., is negative).
       ENOBUFS  Insufficient resources were available in the system to perform the operation.
       ENOTSOCK The file descriptor sockfd does not refer to a socket.

STANDARDS
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (getsockname() first appeared in 4.2BSD).

NOTES
       For background on the socklen_t type, see accept(2).

_______________________________________________________________________________________________________________________
CONNECT

connect(2)
NAME
       connect - initiate a connection on a socket

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <sys/socket.h>

       int connect(int sockfd, const struct sockaddr *addr,
                   socklen_t addrlen);

DESCRIPTION
       The  connect()  system  call connects the socket referred to by the file descriptor sockfd to the address specified by addr.  The
       addrlen argument specifies the size of addr.  The format of the address in addr is determined by the address space of the  socket
       sockfd; see socket(2) for further details.

       If the socket sockfd is of type SOCK_DGRAM, then addr is the address to which datagrams are sent by default, and the only address
       from which datagrams are received.  If the socket is of type SOCK_STREAM or SOCK_SEQPACKET, this call attempts to make a  connec‐
       tion to the socket that is bound to the address specified by addr.

       Some protocol sockets (e.g., UNIX domain stream sockets) may successfully connect() only once.

       Some  protocol sockets (e.g., datagram sockets in the UNIX and Internet domains) may use connect() multiple times to change their
       association.

 	   Some protocol sockets (e.g., TCP sockets as well as datagram sockets in the UNIX and Internet domains) may dissolve the  associa‐
       tion  by connecting to an address with the sa_family member of sockaddr set to AF_UNSPEC; thereafter, the socket can be connected
       to another address.  (AF_UNSPEC is supported since Linux 2.2.)

RETURN VALUE
       If the connection or binding succeeds, zero is returned.  On error, -1 is returned, and errno is set to indicate the error.

ERRORS
       The following are general socket errors only.  There may be other domain-specific error codes.

       EACCES For UNIX domain sockets, which are identified by pathname: Write permission is denied on the socket file, or  search  per‐
              mission is denied for one of the directories in the path prefix.  (See also path_resolution(7).)

       EACCES, EPERM
              The  user  tried  to connect to a broadcast address without having the socket broadcast flag enabled or the connection re‐
              quest failed because of a local firewall rule.

       EACCES It can also be returned if an SELinux policy denied a connection (for example, if there is a policy saying  that  an  HTTP
              proxy can only connect to ports associated with HTTP servers, and the proxy tries to connect to a different port).

       EADDRINUSE
              Local address is already in use.
	   EADDRNOTAVAIL
              (Internet  domain sockets) The socket referred to by sockfd had not previously been bound to an address and, upon attempt‐
              ing to bind it to an ephemeral port, it was determined that all port numbers in the ephemeral port range are currently  in
              use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7).

       EAFNOSUPPORT
              The passed address didn't have the correct address family in its sa_family field.

       EAGAIN For  nonblocking  UNIX domain sockets, the socket is nonblocking, and the connection cannot be completed immediately.  For
              other socket families, there are insufficient entries in the routing cache.

       EALREADY
              The socket is nonblocking and a previous connection attempt has not yet been completed.

       EBADF  sockfd is not a valid open file descriptor.

       ECONNREFUSED
              A connect() on a stream socket found no one listening on the remote address.

       EFAULT The socket structure address is outside the user's address space.

       EINPROGRESS
              The socket is nonblocking and the connection cannot be completed immediately.  (UNIX domain sockets failed with EAGAIN in‐
              stead.)  It is possible to select(2) or poll(2) for completion by selecting the socket for writing.  After select(2) indi‐
              cates writability, use getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to determine whether  connect()  com‐
              pleted successfully (SO_ERROR is zero) or unsuccessfully (SO_ERROR is one of the usual error codes listed here, explaining
              the reason for the failure).

	   EINTR  The system call was interrupted by a signal that was caught; see signal(7).

       EISCONN
              The socket is already connected.

       ENETUNREACH
              Network is unreachable.

       ENOTSOCK
              The file descriptor sockfd does not refer to a socket.

       EPROTOTYPE
              The socket type does not support the requested communications protocol.  This error can occur, for example, on an  attempt
              to connect a UNIX domain datagram socket to a stream socket.

       ETIMEDOUT
              Timeout  while attempting connection.  The server may be too busy to accept new connections.  Note that for IP sockets the
              timeout may be very long when syncookies are enabled on the server.

STANDARDS
       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (connect() first appeared in 4.2BSD).

NOTES
       For background on the socklen_t type, see accept(2).

       If connect() fails, consider the state of the socket as unspecified.  Portable applications should close the socket and create  a
       new one for reconnecting.

_______________________________________________________________________________________________________________________
GETADDRINFO - FREEADDRINFO
NAME
       getaddrinfo, freeaddrinfo, gai_strerror - network address and service translation

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>
       #include <netdb.h>

       int getaddrinfo(const char *restrict node,
                       const char *restrict service,
                       const struct addrinfo *restrict hints,
                       struct addrinfo **restrict res);

       void freeaddrinfo(struct addrinfo *res);

       const char *gai_strerror(int errcode);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       getaddrinfo(), freeaddrinfo(), gai_strerror():
           Since glibc 2.22:
               _POSIX_C_SOURCE >= 200112L
           glibc 2.21 and earlier:
               _POSIX_C_SOURCE

DESCRIPTION
       Given  node  and  service,  which identify an Internet host and a service, getaddrinfo() returns one or more addrinfo structures,
       each of which contains an Internet address that can be specified in a call to bind(2) or connect(2).  The getaddrinfo()  function
       combines  the  functionality  provided by the gethostbyname(3) and getservbyname(3) functions into a single interface, but unlike
       the latter functions, getaddrinfo() is reentrant and allows programs to eliminate IPv4-versus-IPv6 dependencies.

       The addrinfo structure used by getaddrinfo() contains the following fields:

           struct addrinfo {
               int              ai_flags;
               int              ai_family;
               int              ai_socktype;
               int              ai_protocol;
               socklen_t        ai_addrlen;
               struct sockaddr *ai_addr;
               char            *ai_canonname;
               struct addrinfo *ai_next;
           };

       The hints argument points to an addrinfo structure that specifies criteria for selecting the socket address  structures  returned
       in the list pointed to by res.  If hints is not NULL it points to an addrinfo structure whose ai_family, ai_socktype, and ai_pro‐
       tocol specify criteria that limit the set of socket addresses returned by getaddrinfo(), as follows:

       ai_family
              This field specifies the desired address family for the returned addresses.  Valid values for this field  include  AF_INET
              and AF_INET6.  The value AF_UNSPEC indicates that getaddrinfo() should return socket addresses for any address family (ei‐
              ther IPv4 or IPv6, for example) that can be used with node and service.

       ai_socktype
              This field specifies the preferred socket type, for example SOCK_STREAM or SOCK_DGRAM.  Specifying 0 in this  field  indi‐
              cates that socket addresses of any type can be returned by getaddrinfo().

       ai_protocol
              This field specifies the protocol for the returned socket addresses.  Specifying 0 in this field indicates that socket ad‐
              dresses with any protocol can be returned by getaddrinfo().

       ai_flags
              This field specifies additional options, described below.  Multiple flags are specified by bitwise OR-ing them together.

       All the other fields in the structure pointed to by hints must contain either 0 or a null pointer, as appropriate.

       Specifying hints as NULL is equivalent to setting ai_socktype and ai_protocol to 0;  ai_family  to  AF_UNSPEC;  and  ai_flags  to
       (AI_V4MAPPED | AI_ADDRCONFIG).   (POSIX specifies different defaults for ai_flags; see NOTES.)  node specifies either a numerical
       network address (for IPv4, numbers-and-dots notation as supported by inet_aton(3); for IPv6, hexadecimal string  format  as  sup‐
       ported  by  inet_pton(3)), or a network hostname, whose network addresses are looked up and resolved.  If hints.ai_flags contains
       the AI_NUMERICHOST flag, then node must be a numerical network address.   The  AI_NUMERICHOST  flag  suppresses  any  potentially
       lengthy network host address lookups.

       If  the AI_PASSIVE flag is specified in hints.ai_flags, and node is NULL, then the returned socket addresses will be suitable for
       bind(2)ing a socket that will accept(2) connections.  The returned socket address will contain the "wildcard address" (INADDR_ANY
       for  IPv4  addresses,  IN6ADDR_ANY_INIT for IPv6 address).  The wildcard address is used by applications (typically servers) that
       intend to accept connections on any of the host's network addresses.  If node is not NULL, then the AI_PASSIVE flag is ignored.

       If the AI_PASSIVE flag is not set in hints.ai_flags, then the returned socket addresses will be suitable for use with connect(2),
       sendto(2),  or sendmsg(2).  If node is NULL, then the network address will be set to the loopback interface address (INADDR_LOOP‐
       BACK for IPv4 addresses, IN6ADDR_LOOPBACK_INIT for IPv6 address); this is used by applications that intend  to  communicate  with
       peers running on the same host.

       service sets the port in each returned address structure.  If this argument is a service name (see services(5)), it is translated
       to the corresponding port number.  This argument can also be specified as a decimal number, which is simply converted to  binary.
       If service is NULL, then the port number of the returned socket addresses will be left uninitialized.  If AI_NUMERICSERV is spec‐
       ified in hints.ai_flags and service is not NULL, then service must point to a string containing a numeric port number.  This flag
       is used to inhibit the invocation of a name resolution service in cases where it is known not to be required.

       Either node or service, but not both, may be NULL.

       The  getaddrinfo()  function  allocates  and  initializes a linked list of addrinfo structures, one for each network address that
       matches node and service, subject to any restrictions imposed by hints, and returns a pointer to the start of the  list  in  res.
       The items in the linked list are linked by the ai_next field.

       There  are  several  reasons why the linked list may have more than one addrinfo structure, including: the network host is multi‐
       homed, accessible over multiple protocols (e.g., both AF_INET and AF_INET6); or the  same  service  is  available  from  multiple
       socket  types  (one SOCK_STREAM address and another SOCK_DGRAM address, for example).  Normally, the application should try using
       the addresses in the order in which they are returned.  The sorting function used within getaddrinfo() is  defined  in  RFC 3484;
       the order can be tweaked for a particular system by editing /etc/gai.conf (available since glibc 2.5).

       If  hints.ai_flags includes the AI_CANONNAME flag, then the ai_canonname field of the first of the addrinfo structures in the re‐
       turned list is set to point to the official name of the host.

       The remaining fields of each returned addrinfo structure are initialized as follows:

       •  The ai_family, ai_socktype, and ai_protocol fields return the socket creation parameters (i.e., these  fields  have  the  same
          meaning  as  the  corresponding arguments of socket(2)).  For example, ai_family might return AF_INET or AF_INET6; ai_socktype
          might return SOCK_DGRAM or SOCK_STREAM; and ai_protocol returns the protocol for the socket.

       •  A pointer to the socket address is placed in the ai_addr field, and the length of the socket address, in bytes, is  placed  in
          the ai_addrlen field.

       If hints.ai_flags includes the AI_ADDRCONFIG flag, then IPv4 addresses are returned in the list pointed to by res only if the lo‐
       cal system has at least one IPv4 address configured, and IPv6 addresses are returned only if the local system has  at  least  one
       IPv6  address  configured.   The loopback address is not considered for this case as valid as a configured address.  This flag is
       useful on, for example, IPv4-only systems, to ensure that getaddrinfo() does not return IPv6 socket addresses that  would  always
       fail in connect(2) or bind(2).

       If  hints.ai_flags  specifies the AI_V4MAPPED flag, and hints.ai_family was specified as AF_INET6, and no matching IPv6 addresses
       could be found, then return IPv4-mapped IPv6 addresses in the list pointed to by res.  If both AI_V4MAPPED and AI_ALL are  speci‐
       fied in hints.ai_flags, then return both IPv6 and IPv4-mapped IPv6 addresses in the list pointed to by res.  AI_ALL is ignored if
       AI_V4MAPPED is not also specified.

       The freeaddrinfo() function frees the memory that was allocated for the dynamically allocated linked list res.

   Extensions to getaddrinfo() for Internationalized Domain Names
       Starting with glibc 2.3.4, getaddrinfo() has been extended to selectively allow the incoming and outgoing hostnames to be  trans‐
       parently  converted  to and from the Internationalized Domain Name (IDN) format (see RFC 3490, Internationalizing Domain Names in
       Applications (IDNA)).  Four new flags are defined:

       AI_IDN If this flag is specified, then the node name given in node is converted to IDN format if necessary.  The source  encoding
              is that of the current locale.

              If  the  input name contains non-ASCII characters, then the IDN encoding is used.  Those parts of the node name (delimited
              by dots) that contain non-ASCII characters are encoded using ASCII Compatible Encoding (ACE) before being  passed  to  the
              name resolution functions.

       AI_CANONIDN
              After  a  successful name lookup, and if the AI_CANONNAME flag was specified, getaddrinfo() will return the canonical name
              of the node corresponding to the addrinfo structure value passed back.  The return value is an exact copy of the value re‐
              turned by the name resolution function.

              If the name is encoded using ACE, then it will contain the xn-- prefix for one or more components of the name.  To convert
              these components into a readable form the AI_CANONIDN flag can be passed  in  addition  to  AI_CANONNAME.   The  resulting
              string is encoded using the current locale's encoding.

       AI_IDN_ALLOW_UNASSIGNED, AI_IDN_USE_STD3_ASCII_RULES
              Setting   these   flags   will   enable   the   IDNA_ALLOW_UNASSIGNED   (allow   unassigned   Unicode   code  points)  and
              IDNA_USE_STD3_ASCII_RULES (check output to make sure it is a STD3 conforming hostname) flags respectively to  be  used  in
              the IDNA handling.

RETURN VALUE
       getaddrinfo() returns 0 if it succeeds, or one of the following nonzero error codes:

       EAI_ADDRFAMILY
              The specified network host does not have any network addresses in the requested address family.

       EAI_AGAIN
              The name server returned a temporary failure indication.  Try again later.

       EAI_BADFLAGS
              hints.ai_flags contains invalid flags; or, hints.ai_flags included AI_CANONNAME and name was NULL.

       EAI_FAIL
              The name server returned a permanent failure indication.

       EAI_FAMILY
              The requested address family is not supported.

       EAI_MEMORY
              Out of memory.

       EAI_NODATA
              The specified network host exists, but does not have any network addresses defined.

       EAI_NONAME
              The node or service is not known; or both node and service are NULL; or AI_NUMERICSERV was specified in hints.ai_flags and
              service was not a numeric port-number string.

       EAI_SERVICE
              The requested service is not available for the requested socket type.  It may be available through  another  socket  type.
              For  example,  this  error  could  occur  if  service was "shell" (a service available only on stream sockets), and either
              hints.ai_protocol was IPPROTO_UDP, or hints.ai_socktype was SOCK_DGRAM; or the error could occur if service was not  NULL,
              and hints.ai_socktype was SOCK_RAW (a socket type that does not support the concept of services).

       EAI_SOCKTYPE
              The requested socket type is not supported.  This could occur, for example, if hints.ai_socktype and hints.ai_protocol are
              inconsistent (e.g., SOCK_DGRAM and IPPROTO_TCP, respectively).

       EAI_SYSTEM
              Other system error; errno is set to indicate the error.

       The gai_strerror() function translates these error codes to a human readable string, suitable for error reporting.

FILES
       /etc/gai.conf

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌───────────────────────────────────────────────────────────────────────────────────────────┬───────────────┬────────────────────┐
       │Interface                                                                                  │ Attribute     │ Value              │
       ├───────────────────────────────────────────────────────────────────────────────────────────┼───────────────┼────────────────────┤
       │getaddrinfo()                                                                              │ Thread safety │ MT-Safe env locale │
       ├───────────────────────────────────────────────────────────────────────────────────────────┼───────────────┼────────────────────┤
       │freeaddrinfo(), gai_strerror()                                                             │ Thread safety │ MT-Safe            │
       └───────────────────────────────────────────────────────────────────────────────────────────┴───────────────┴────────────────────┘

STANDARDS
       POSIX.1-2001, POSIX.1-2008.  The getaddrinfo() function is documented in RFC 2553.

NOTES
       getaddrinfo() supports the address%scope-id notation for specifying the IPv6 scope-ID.

       AI_ADDRCONFIG, AI_ALL, and AI_V4MAPPED are available since glibc 2.3.3.  AI_NUMERICSERV is available since glibc 2.3.4.

       According to POSIX.1, specifying hints as NULL should cause ai_flags to be assumed as 0.  The GNU C  library  instead  assumes  a
       value of (AI_V4MAPPED | AI_ADDRCONFIG) for this case, since this value is considered an improvement on the specification.

EXAMPLES
       The  following  programs  demonstrate the use of getaddrinfo(), gai_strerror(), freeaddrinfo(), and getnameinfo(3).  The programs
       are an echo server and client for UDP datagrams.

   Server program

       #include <netdb.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>
       #include <sys/socket.h>
       #include <sys/types.h>
       #include <unistd.h>

       #define BUF_SIZE 500

       int
       main(int argc, char *argv[])
       {
           int                      sfd, s;
           char                     buf[BUF_SIZE];
           ssize_t                  nread;
           socklen_t                peer_addrlen;
           struct addrinfo          hints;
           struct addrinfo          *result, *rp;
           struct sockaddr_storage  peer_addr;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s port\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           memset(&hints, 0, sizeof(hints));
           hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
           hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
           hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */
           hints.ai_protocol = 0;          /* Any protocol */
           hints.ai_canonname = NULL;
           hints.ai_addr = NULL;
           hints.ai_next = NULL;

           s = getaddrinfo(NULL, argv[1], &hints, &result);
           if (s != 0) {
               fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
               exit(EXIT_FAILURE);
           }

           /* getaddrinfo() returns a list of address structures.
              Try each address until we successfully bind(2).
              If socket(2) (or bind(2)) fails, we (close the socket
              and) try the next address. */

           for (rp = result; rp != NULL; rp = rp->ai_next) {
               sfd = socket(rp->ai_family, rp->ai_socktype,
                            rp->ai_protocol);
               if (sfd == -1)
                   continue;

               if (bind(sfd, rp->ai_addr, rp->ai_addrlen) == 0)
                   break;                  /* Success */

               close(sfd);
           }

           freeaddrinfo(result);           /* No longer needed */

           if (rp == NULL) {               /* No address succeeded */
               fprintf(stderr, "Could not bind\n");
               exit(EXIT_FAILURE);
           }

           /* Read datagrams and echo them back to sender. */

           for (;;) {
               char host[NI_MAXHOST], service[NI_MAXSERV];

               peer_addrlen = sizeof(peer_addr);
               nread = recvfrom(sfd, buf, BUF_SIZE, 0,
                                (struct sockaddr *) &peer_addr, &peer_addrlen);
               if (nread == -1)
                   continue;               /* Ignore failed request */

               s = getnameinfo((struct sockaddr *) &peer_addr,
                               peer_addrlen, host, NI_MAXHOST,
                               service, NI_MAXSERV, NI_NUMERICSERV);
               if (s == 0)
                   printf("Received %zd bytes from %s:%s\n",
                          nread, host, service);
               else
                   fprintf(stderr, "getnameinfo: %s\n", gai_strerror(s));

               if (sendto(sfd, buf, nread, 0, (struct sockaddr *) &peer_addr,
                          peer_addrlen) != nread)
               {
                   fprintf(stderr, "Error sending response\n");
               }
           }
       }

   Client program

       #include <netdb.h>
       #include <stdio.h>
       #include <stdlib.h>
       #include <string.h>
       #include <sys/socket.h>
       #include <sys/types.h>
       #include <unistd.h>

       #define BUF_SIZE 500

       int
       main(int argc, char *argv[])
       {
           int              sfd, s;
           char             buf[BUF_SIZE];
           size_t           len;
           ssize_t          nread;
           struct addrinfo  hints;
           struct addrinfo  *result, *rp;

           if (argc < 3) {
               fprintf(stderr, "Usage: %s host port msg...\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           /* Obtain address(es) matching host/port. */

           memset(&hints, 0, sizeof(hints));
           hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
           hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
           hints.ai_flags = 0;
           hints.ai_protocol = 0;          /* Any protocol */

           s = getaddrinfo(argv[1], argv[2], &hints, &result);
           if (s != 0) {
               fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
               exit(EXIT_FAILURE);
           }

           /* getaddrinfo() returns a list of address structures.
              Try each address until we successfully connect(2).
              If socket(2) (or connect(2)) fails, we (close the socket
              and) try the next address. */

           for (rp = result; rp != NULL; rp = rp->ai_next) {
               sfd = socket(rp->ai_family, rp->ai_socktype,
                            rp->ai_protocol);
               if (sfd == -1)
                   continue;

               if (connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)
                   break;                  /* Success */

               close(sfd);
           }

           freeaddrinfo(result);           /* No longer needed */

           if (rp == NULL) {               /* No address succeeded */
               fprintf(stderr, "Could not connect\n");
               exit(EXIT_FAILURE);
           }

           /* Send remaining command-line arguments as separate
              datagrams, and read responses from server. */

           for (size_t j = 3; j < argc; j++) {
               len = strlen(argv[j]) + 1;
                       /* +1 for terminating null byte */

               if (len > BUF_SIZE) {
                   fprintf(stderr,
                           "Ignoring long message in argument %zu\n", j);
                   continue;
               }


               if (write(sfd, argv[j], len) != len) {
                   fprintf(stderr, "partial/failed write\n");
                   exit(EXIT_FAILURE);
               }

               nread = read(sfd, buf, BUF_SIZE);
               if (nread == -1) {
                   perror("read");
                   exit(EXIT_FAILURE);
               }

               printf("Received %zd bytes: %s\n", nread, buf);
           }

           exit(EXIT_SUCCESS);
       }

_______________________________________________________________________________________________________________________
bind, listen, accept, send, recv, poll (ou équivalent select(), kqueue(), ou epoll())