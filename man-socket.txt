Lors d'acces a une machine, celle-ci se presente a travers une adresse IP permettant son identification.
De nombreux logiciels sont simultanement utilises sur la meme machine. Afin de preciser vers quel logiciel la communication
s'effectue, un socket est attribuer a un logiciel accedant au reseau depuis la machine, agissant comme identifiant supplementaire.
Une socket est simplement un moyen de désigner l’extrémité d’un canal de communication bidirectionnel, côté client ou serveur, 
en l’associant à un port.

Dans le cas du protocol TCP/IP (transmission control protocol / internet protocol)
Un numéro de port comprend 16 bits (0 à 65 535) et est associé à un protocole de transport donné
	(le port TCP n°i et le port UDP n°i )
le port TCP etablie une connexion prealable entre deux hotes, permettant des echange par cette liaison
le port UDP (user datagram protocol) n'est pas prealablement connecter, les echanges s'effectue alors message par message (non utilise pour nous).

le protocol TCP/IP permet alors
	- transmission bidirectionnelle par flot d'octet
	- garatie la fiabilite de l'echange des lors que la liaison physique est cree
	- garantie un flux ordonne (ordre de reception identique a la transmission)
	- Contrôle de flux. Permet au récepteur de limiter le débit d’émission en fonction de ses capacités de réception (entre récepteur et émetteur)
	- Contrôle de congestion. Permet d’agir sur le débit d’émission pour éviter la surcharge du réseau (entre réseau et émetteur)

SERVER SOCKET TCP
Un serveur en mode connecté doit attendre une nouvelle demande de connexion de la part d’un client, 
puis traiter la (ou les requêtes) envoyée(s) sur cette connexion par le client.
Les fonctions d’attente et de traitement sont séparées, pour permettre au serveur d’attendre de nouvelles demandes de 
connexion pendant qu’il traite des requêtes en cours.

La socket serveur est associée à un numéro de port connu des clients (par ex. port 80 pour un serveur web, etc.)
Chaque nouvelle connexion établie par le système d’exploitation du serveur est placée dans la file d’attente.
Si une demande de connexion arrive alors que la file est pleine, elle est rejetée (pourra être réessayée plus tard) -> voir connect()
La socket de communication est creer lors de la demande de connexion d'un client. Elle est associée au même numéro 
de port que la socket serveur, mais avec un descripteur différent

Etape 1 : créer une socket serveur TCP
					ServerSocket servSock = new ServerSocket();
Etape 2.a : associer la socket à une adresse IP et un numéro de port TCP locaux 
					int myPort = …
					InetSocketAddress ipAddrAndPort;
					ipAddrAndPort = new InetSocketAddress(myPort);
					servSock.bind(ipAddrAndPort, …);
Eape 2.b : définir la taille de la file d’attente pour les nouvelles connexions
					int backlogSize = …;
					…
					servSock.bind(ipAddrAndPort, backlogSize);
Etape 3a : permettre à l’application (côté serveur) de prendre connaissance d’une nouvelle connexion
					Socket sock;
					…
					sock = servSock.accept();					==> /!\ la primitive accept est bloquante (si la file est vide)
Etape 3b : obtention d’un canal de communication/dialogue par l’application (côté serveur)
					sock = servSock.accept();					==> au retour de accept() la connexion est supprimee de la file d'attente

CLIENT SOCKET TCP
Ici on connaît l’adresse d’un serveur et le numéro de port (TCP) d’une socket serveur sur celui-ci 
(un processus serveur est en attente sur ce port).

Etape 1 : créer une socket :
					Socket sock = new Socket();
Etape 1 bis : associer la socket à une adresse et/ou un numéro de port (locaux) particuliers (pas toujours necessaire a creer)
					InetSocketAddress localIpAddrAndPort = new InetSocketAddress(…);
					sock.bind(localIpAddrAndPort);
		Choisit un numéro de port libre dans une plage prédéfinie (ports dit « éphémères » ou « dynamiques »)
		Si la machine possède plusieurs adresses IP, associe à la socket l’adresse IP par défaut de la machine
Etape 2 : établir une connexion entre la socket client et le serveur
					InetSocketAddress serverIpAddrAndPort = new InetSocketAddress(…);
					sock.connect(serverIpAddrAndPort);			==> connect envoie une demande de connexion vers la socket serveur
																	(une exceptionIOException est levée en cas d’échec de la connexion)

ECHANGES 
Une fois la connexion établie, le client et le serveur disposent chacun d’un descripteur (pseudo-fichier) 
vers l’extrémité correspondante de la connexion (avec un flux d'entre et de sortie).
Le fonctionnement des flux est similaire au pipe FIFO :	entre client -> sortie server
														entre server -> sortie client
Une lecture sur un flux d’entrée peut être bloquante (si le tampon de réception ne contient pas de nouvelles données),
jusqu’à l’arrivée de nouvelles données envoyées par l’interlocuteur (ou jusqu’à la rupture de la connexion réseau).

VOIR LES SOCKET - command shell
	netstat -t -a --numeric-ports --numeric-hosts
	ss -t
'ss' Options utiles
	-a ou --all : permet d’afficher toutes les sockets existantes sur la machine (par défaut, seules les sockets connectées sont listées)
	-l ou --listening : affiche uniquement les sockets serveurs
	-p : affiche le pid du processus propriétaire d’une socket
	-e : permet de connaître l’utilisateur associé au processus propriétaire d’une socket
	-n ou --numeric : désactiver la résolution des noms de services
	-r ou --resolve : activer la résolution des noms de machines et de services

	port : 16 bits (0 à 65 535) = USHORT
			Les numéros de 0 à 1023 sont réservés, par convention, à des services spécifiques.
			Exemples (avec TCP) :
			7 : echo 	25 : SMTP (acheminement mail) 	443 : HTTPS (HTTP sécurisé)
			22 : SSH 	80 : HTTP (serveur web) 		465 : SMTPS (SMTP sécurisé)
_______________________________________________________________________________________________________________________
socket(7)
#include <sys/socket.h>
sockfd = socket(int famille_socket, int type_socket, int protocole); 


socket(2) crée une socket																					==> <socket()> autorised
connect(2) connecte une socket à une adresse de socket distante												==> <connect()> autorised
bind(2) attache une socket à une adresse local																==> <bind()> autorised
listen(2) indique à la socket que de nouvelles connexions doivent être acceptées							==> <listen()> autorised
accept(2) fournit une nouvelle socket avec la nouvelle connexion entrante. 									==> <accept()> autorised
socketpair(2) renvoie deux sockets anonymes connectées (seulement implémenté pour quelques familles locales comme AF_UNIX).

send(2), sendto(2), et sendmsg(2) envoient des données sur une socket										==> <send()> autorised
recv(2), recvfrom(2) et recvmsg(2) reçoivent les données envoyées par une socket							==> <recv()> autorised
poll(2) et select(2) attendent que des données arrivent ou que l'émission soit possible. 					==> <poll()> or <select()> autorised

De plus, les opérations d'entrée-sortie standard comme write(2), writev(2), sendfile(2), read(2) et readv(2)
peuvent être utilisées pour la lecture et l'écriture des données.

getsockname(2) renvoie l'adresse de la socket locale														==> <getsockname()> aurotised
getpeername(2) renvoie l'adresse de la socket distante. 
getsockopt(2) et setsockopt(2) servent à définir et obtenir les options de la couche socket ou protocole. 	==> <setsockopt()> autorised
ioctl(2) peut être utilisé pour lire et écrire d'autres options.

close(2) sert à fermer une socket. shutdown(2) ferme une partie des connexions d'une socket multiple.		==> <close()> autorised

La recherche ou l'utilisation de pread(2) et pwrite(2) avec un décalage non nul n'est pas possible sur les sockets.

Des opérations d'entrée-sortie non bloquantes sur les sockets sont possibles en définissant 
l'attribut O_NONBLOCK du descripteur de la socket avec fcntl(2). Toutes les opérations qui 					==> /!\ memoire --> use <poll()>
devraient normalement bloquer se terminent alors avec l'erreur EAGAIN (l'opération devra être 
retentée ultérieurement). 
connect(2) renverra l'erreur EINPROGRESS. L'utilisateur peut alors attendre divers événements avec poll(2) ou select(2).
			Événements E/S
Événement		Appel		Circonstance
Lecture			POLLIN		Arrivée de nouvelles données
Lecture			POLLIN		Configuration d'une connexion achevée (pour les sockets orientées connexion)
Lecture			POLLHUP		Demande de déconnexion initiée par l'autre extrémité
Lecture			POLLHUP		Connexion rompue (seulement pour les protocoles orientés connexion) 
								Lors de l'écriture sur la socket, le signal SIGPIPE est aussi émis.
Écriture		POLLOUT		La socket a assez de place dans le tampon d'émission pour écrire de nouvelles données.
Lect./Écrit.	POLLIN|
				POLLOUT 	Un appel sortant à connect(2) est terminé.
Lect./Écrit.	POLLERR		Une erreur asynchrone s'est produite.
Lect./Écrit.	POLLHUP		Le correspondant a clos un sens de communication.
Exception		POLLPRI		Arrivée de données urgentes. SIGURG est alors envoyé.

Une alternative à poll(2) et select(2) est de laisser le noyau informer l'application des événements par 
l'intermédiaire d'un signal SIGIO. Pour cela, l'attribut O_ASYNC doit être défini sur un descripteur de fichier 
de la socket via fcntl(2) et un gestionnaire de signal valable pour SIGIO doit être installé avec sigaction(2). 
Consultez les remarques sur les Signaux ci-dessous.

Structures d'adresse de socket
Chaque domaine de socket a son propre format pour les adresses de socket, avec une structure d'adresse propre. 
Chacune de ces structures commence avec un champ entier « family » (famille), de type sa_family_t, qui indique 
le type de structure d'adresse. Cela permet aux appels système génériques à tous les domaines de sockets 
(par exemple connect(2), bind(2), accept(2), getsockname(2), getpeername(2)) de déterminer le domaine d'une adresse de socket donnée.

Le type struct sockaddr est défini afin de pouvoir passer n'importe quel type d'adresse de socket aux interface 
dans l'API des sockets. Le but de ce type est purement d'autoriser la conversion de types d'adresse de socket propres 
à un domaine vers le type « générique », afin d'éviter les avertissements du compilateur au sujet de la non 
correspondance dans les appels de l'API des sockets.

De plus, l'API des sockets fournit le type de données struct sockaddr_storage. Ce type est fait pour contenir toute 
structure d'adresse de socket spécifique à un domaine. Il est suffisamment grand et est aligné correctement 
(en particulier, il est assez grand pour contenir des adresses de socket IPv6). 
Cette structure contient le champ suivant, qui peut être utilisé pour identifier le type d'adresse socket 
effectivement stockée dans la structure :

    sa_family_t ss_family;

La structure sockaddr_storage est utile dans les programmes qui doivent prendre en charge les adresses de socket 
de manière générique (par exemple les programmes qui doivent gérer à la fois des adresses de socket IPv4 et IPv6).

Options de sockets
Les options présentées ci-dessous peuvent être définies en utilisant setsockopt(2) et lues avec getsockopt(2) 
avec le niveau de socket positionné à SOL_SOCKET, et ce pour toutes les sockets. 
Sauf mention contraire, optval est un pointeur vers un int.

SO_ACCEPTCONN																										==> peut etre utile en debug
    Renvoie une valeur indiquant si la socket a été déclarée comme acceptant les connexions à l'aide de listen(2). 
	La valeur 0 indique que la socket n'est pas en attente de connexions et la valeur 1 indique que la socket 
	accepte les connexions. Cette option de socket peut être seulement lue, et pas modifiée. 
SO_BINDTODEVICE
    Attache cette socket à un périphérique donné, tel que « eth0 », comme indiqué dans le nom d'interface transmis. 
	Si le nom est une chaîne vide ou si la longueur de l'option est nulle, la socket est détachée du périphérique. 
	L'option transmise est une chaîne de longueur variable terminée par un caractère nul, contenant le nom de 
	l'interface, la longueur maximale étant IFNAMSIZ. Si une socket est attachée à une interface, seuls les paquets 
	reçus de cette interface particulière sont traités par la socket. Cela ne fonctionne que pour certains types de 
	sockets, en particulier les sockets AF_INET. Ce n'est pas géré pour les sockets paquet (utilisez pour cela bind(2)).

    Avant Linux 3.8, cette option de socket pouvait être configurée, sans pouvoir être lue par getsockopt(2). 
	Depuis Linux 3.8, elle est lisible. Le paramètre optlen doit contenir la taille du tampon destiné à recevoir le nom 
	du périphérique, préférablement IFNAMSZ. La véritable longueur du nom du périphérique est renvoyée dans le paramètre optlen. 
SO_BROADCAST
    Définir ou lire l'attribut de diffusion. Une fois activé, les sockets de datagrammes sont autorisées à envoyer 
	des paquets à une adresse de diffusion. Cette option n'a aucun effet sur les sockets orientées flux. 
SO_BSDCOMPAT
    Active la compatibilité BSD bogue-à-bogue. Cela est utilisé par le module du protocole UDP de Linux 2.0 et 2.2. 
	Si cette compatibilité est activée, les erreurs ICMP reçues pour une socket UDP ne seront pas transmises au 
	programme utilisateur. Dans les versions récentes du noyau, la gestion de cette option a été abandonnée 
	progressivement : Linux 2.4 l'ignore silencieusement et Linux 2.6 génère une alerte noyau (printk()) si le 
	programme utilise cette option. Linux 2.0 activait également les options de compatibilité BSD bogue-à-bogue 
	(modification aléatoire des en-têtes, non prise en compte de l'attribut de diffusion) pour les sockets brutes 
	ayant cette option, mais cela a été éliminé dans Linux 2.2. 
SO_DEBUG
    Active le débogage de socket. Cela n'est autorisé que pour les processus avec la capacité CAP_NET_ADMIN ou un 
	identifiant d'utilisateur effectif égal à 0. 
SO_DOMAIN (depuis Linux 2.6.32)
    Récupère le domaine de socket en tant qu'entier, en renvoyant une valeur telle que AF_INET6. 
	Consultez socket(2) pour plus de détails. Cette option de socket peut être seulement lue, et pas modifiée. 
SO_ERROR
	Lit et efface l'erreur en cours sur la socket. Cette option de socket peut être seulement lue, et pas modifiée.
	Demande un entier. 
SO_DONTROUTE
    Ne pas émettre par l'intermédiaire d'une passerelle, n'envoyer qu'aux hôtes directement connectés. 
	Le même effet peut être obtenu avec l'attribut MSG_DONTROUTE durant une opération send(2) sur la socket. 
	Demande un attribut entier booléen. 
SO_KEEPALIVE
    Active l'émission de messages périodiques gardant la socket ouverte pour les sockets orientées connexion. 
	Demande un attribut entier booléen. 
SO_LINGER
    Définit ou lit l'option SO_LINGER. Le paramètre est une structure linger.

    struct linger {
        int l_onoff;    /* définition de l'activité */
        int l_linger;   /* durée d'attente en secondes */
    };

    Lorsque ce paramètre est actif, un appel à close(2) ou shutdown(2) ne se terminera pas avant que tous les 
	messages en attente pour la socket aient été correctement émis ou que le délai d'attente soit écoulé. 
	Sinon, l'appel se termine immédiatement et la fermeture est effectuée en arrière-plan. Lorsque la socket 
	est fermée au cours d'un exit(2), elle attend toujours en arrière-plan. 
SO_MARK (depuis Linux 2.6.25)
    Positionner la marque pour chaque paquet envoyé au travers de cette socket (similaire à la cible MARK de 
	netfilter, mais pour les sockets). Le changement de marque peut être utilisé pour un routage par marques 
	sans netfilter ou pour le filtrage de paquets. Utiliser cette option nécessite la capacité CAP_NET_ADMIN. 
SO_OOBINLINE
    Si cette option est activée, les données hors bande sont placées directement dans le flux des données reçues. 
	Sinon, elles ne sont transmises que si l'attribut MSG_OOB est défini durant la réception. 
SO_PASSCRED
    Autorise ou interdit la réception des messages de contrôle SCM_CREDENTIALS. 
	Pour plus de détails, consultez unix(7). 
SO_PEEK_OFF (depuis Linux 3.4)
    Cette option, qui n'est à ce jour garantie que pour les sockets unix(7), définit la valeur de la 
	« position de lecture » (ou « peek offset ») pour l'appel système recv(2) lorsqu'il est invoqué avec l'attribut MSG_PEEK.

    Lorsque cette option reçoit une valeur négative (elle est initialisée à -1 pour toute nouvelle socket), 
	elle se comporte classiquement : recv(2), avec l'attribut MSG_PEEK, lit les données depuis le début de la file.

    Lorsque l'option reçoit une valeur supérieure ou égale à zéro, alors la lecture suivante des données accumulées 
	dans la socket est réalisée à la position précisée par la valeur de l'option. Dans le même temps, la 
	« position de lecture » est incrémentée du nombre d'octets lus dans la file, de façon à ce que la prochaine 
	lecture renvoie la donnée suivante dans la file.

    Si des données sont retirées de la tête de la file par la fonction recv(2) (ou équivalent) sans l'attribut MSG_PEEK, 
	alors la « position de lecture » est diminuée du nombre d'octets supprimés. Autrement dit, l'acquisition de données 
	sans avoir recours à l'attribut MSG_PEEK a pour effet de modifier la « position de lecture », de sorte que la prochaine 
	lecture renvoie les données qui auraient été renvoyées si aucune donnée n'avait été supprimée.

    Pour les sockets de datagrammes, si la « position de lecture » pointe à l'intérieur d'un paquet, alors les données 
	renvoyées seront marquées de l'attribut MSG_TRUNC.

    L'exemple suivant illustre l'usage de SO_PEEK_OFF. Imaginons une socket de flux contenant les données suivantes dans sa file :


        aabbccddeeff

    La séquence suivante d'appels à recv(2) aura l'effet décrit dans les commentaires :

    int ov = 4;                  // affecte 4 à la position de lecture
    setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));
    recv(fd, buf, 2, MSG_PEEK);  // Lit "cc"; l'indide de position prend la valeur 6
    recv(fd, buf, 2, MSG_PEEK);  // Lit "dd"; l'indice de position prend la valeur 8
    recv(fd, buf, 2, 0);         // Lit "aa"; l'indice de position prend la valeur 6
    recv(fd, buf, 2, MSG_PEEK);  // Lit "ee"; l'indice position prend la valeur 8

SO_PEERCRED
    Renvoie les données d'authentification du processus étranger connecté à cette socket. Cela n'est possible 
	que pour les sockets de flux AF_UNIX connectées et les paires de sockets AF_UNIX de flux et de datagrammes 
	crées avec socketpair(2) ; consultez unix(7). Les données retournées sont celles qui étaient effectives au 
	moment de l'appel à connect(2) ou socketpair(2). L'argument est une structure ucred. Il faut définir la macro 
	de test de fonctionnalité _GNU_SOURCE pour activer la définition de cette structure dans <sys/socket.h>. 
	Cette option de socket peut être seulement lue, et pas modifiée. 
SO_PRIORITY
    Définir la priorité définie par le protocole pour tous les paquets envoyés sur la socket. Linux utilise cette 
	valeur pour trier les files réseau : les paquets avec une priorité élevée peuvent être traités d'abord, en 
	fonction de la gestion des files sur le périphérique. Pour ip(7), cela définit aussi le champ 
	IP Type-Of-Service (TOS) pour les paquets sortants. 
	Établir une priorité en dehors de l'intervalle allant de 0 à 6 nécessite la capacité CAP_NET_ADMIN. 
SO_PROTOCOL (depuis Linux 2.6.32)																					==> peut etre utile debug
    Récupère le protocole de socket en tant qu'entier, en renvoyant une valeur telle que IPPROTO_SCTP. 
	Consultez socket(2) pour plus de détails. Cette option de socket peut être seulement lue, et pas modifiée. 
SO_RCVBUF
    Définit ou lit la taille maximale en octets du tampon de réception. Le noyau double cette valeur (pour 
	prévoir de l'espace pour les opérations de service) lorsque la valeur est définie avec setsockopt(2), et 
	cette valeur doublée est retournée par getsockopt(2). 
	La valeur par défaut est définie par le fichier /proc/sys/net/core/rmem_default 
	et la valeur maximale autorisée est définie par le fichier /proc/sys/net/core/rmem_max. 
	La valeur (doublée) minimale pour cette option est 256. 
SO_RCVBUFFORCE (depuis Linux 2.6.14)
    En utilisant cette option de socket, un processus privilégié (CAP_NET_ADMIN) peut exécuter la même tâche que 
	SO_RCVBUF, mais la limite rmem_max peut être remplacée. 
SO_RCVLOWAT et SO_SNDLOWAT
    Indique le nombre minimal d'octets dans le tampon pour que la couche socket passe les données au protocole 
	(SO_SNDLOWAT) ou à l'utilisateur en réception (SO_RCVLOWAT). Ces deux valeurs sont initialisées à 1. 
	SO_SNDLOWAT n'est pas modifiable (setsockopt(2) échoue avec l'erreur ENOPROTOOPT). SO_RCVLOWAT est 
	modifiable seulement depuis Linux 2.4. Les appels système select(2) et poll(2) ne respectent pour le moment 
	pas la définition de SO_RCVLOWAT sur Linux, et marque la socket comme lisible même lorsqu'un unique octet de 
	données est disponible. La lecture suivante depuis la socket sera bloquée jusqu'à ce que SO_RCVLOWAT octets soient disponibles. 
SO_RCVTIMEO et SO_SNDTIMEO																							==> reperer erreur flux connexion
    Indiquer le délai maximal d'émission ou de réception avant de signaler une erreur. 
	Le paramètre est une structure timeval. Si une fonction d'entrée ou de sortie bloque pendant cet intervalle de 
	temps et que des données ont été envoyées ou reçues, la valeur de retour de cette fonction sera la quantité de 
	données transmises ; si aucune donnée n'a été transmise et si le délai d'attente est atteint, -1 est renvoyé et 
	errno est positionnée à EAGAIN ou EWOULDBLOCK, ou EINPROGRESS (pour connect(2)), comme si la socket avait été 
	définie comme non bloquante. Si le délai d'attente est défini à zéro (valeur par défaut), l'opération ne sera 
	jamais interrompue. Les délais n'ont d'effet que pour les appels système faisant des E/S sur des sockets 
	(par exemple read(2), recvmsg(2), send(2), sendmsg(2)) ; ils n'ont pas d'effet pour select(2), poll(2), epoll_wait(2), etc. 
SO_REUSEADDR
    Indique que les règles utilisées pour la validation des adresses fournies dans un appel à bind(2) doivent 
	autoriser la réutilisation des adresses locales. Pour les sockets AF_INET, cela signifie que la socket peut 
	être attachée à n'importe quelle adresse sauf lorsqu'une socket active en écoute y est liée. 
	Lorsque la socket en écoute est attachée à INADDR_ANY avec un port spécifique, il n'est pas possible de 
	s'attacher à ce port quelle que soit l'adresse locale. L'argument est un attribut booléen entier. 
SO_RXQ_OVFL (depuis Linux 2.6.33)
    Indique qu'un message auxiliaire (cmsg) sous la forme d'une valeur non-signée et codée sur 32 bits doit
	être jointe aux tampons de sockets (skbs), indiquant le nombre de paquets perdus par la socket entre les 
	deux derniers paquets reçus. 
SO_SNDBUF
    Définit ou lit la taille maximale en octets du tampon d'émission. Le noyau double cette valeur (pour prévoir 
	de l'espace pour les opérations de service) lorsque la valeur est définie avec setsockopt(2), et cette valeur 
	doublée est retournée par getsockopt(2). 
	La valeur par défaut est définie par le fichier /proc/sys/net/core/wmem_default 
	et la valeur maximale autorisée est définie par le fichier /proc/sys/net/core/wmem_max. 
	La valeur (doublée) minimale pour cette option est 2048. 
SO_SNDBUFFORCE (depuis Linux 2.6.14)
    En utilisant cette option de socket, un processus privilégié (CAP_NET_ADMIN) peut exécuter la même tâche que 
	SO_SNDBUF, mais la limite wmem_max peut être remplacée. 
SO_TIMESTAMP
    Active ou désactive la réception des messages de contrôle SO_TIMESTAMP. Le message de contrôle d'horodatage 
	est envoyé avec le niveau SOL_SOCKET et le champ cmsg_data est une structure timeval indiquant la date de 
	réception du dernier paquet fourni à l'utilisateur dans cet appel. 
	Consultez cmsg(3) pour plus de détails sur les messages de contrôle. 
SO_TYPE
    Lit le type de socket, sous forme d'entier (comme SOCK_STREAM). 
	Cette option de socket peut être seulement lue, et pas modifiée. 
SO_BUSY_POLL (depuis Linux 3.11)
    Définit la durée approximative, en milliseconde, d’attente active de réception bloquante en absence de données. 
	CAP_NET_ADMIN est nécessaire pour augmenter cette valeur. La valeur par défaut pour cette option est contrôlée 
	par le fichier /proc/sys/net/core/busy_read.

    La valeur dans le fichier /proc/sys/net/core/busy_poll détermine la durée pendant laquelle select(2) et poll(2)
	seront en attente active lors d’une opération sur des sockets avec SO_BUSY_POLL défini et qu’aucun événement à
	signaler n’est trouvé.

    Dans les deux cas, l’attente active ne sera réalisée que lorsque les dernières données reçues par la socket 
	proviennent d’un périphérique réseau qui ne prend pas en charge cette option.

    Bien que l’attente active peut améliorer la latence de quelques applications, une attention particulière doit 
	être portées à son utilisation puisque cela augmentera à la fois l’utilisation du processeur et la consommation puissance. 


Signaux
Lors de l'écriture sur une socket orientée connexion qui a été fermée (localement ou à l'autre extrémité), 			==> /!\
le signal SIGPIPE est envoyé au processus qui écrivait, et EPIPE est renvoyé. 
Le signal n'est pas envoyé lorsque l'appel d'écriture indiqué contenait l'attribut MSG_NOSIGNAL.

Lorsque demandé avec l'option FIOSETOWN de fcntl(2) ou l'option SIOCSPGRP de ioctl(2), le signal SIGIO est 
envoyé quand un événement d'entrée-sortie a lieu. Il est possible d'utiliser poll(2) ou select(2) dans le 
gestionnaire de signal pour savoir sur quelle socket l'événement s'est produit. Une alternative 
(sous Linux 2.2) est de définir un signal en temps-réel avec le fnctl(2) F_SETSIG. Le gestionnaire du 
signal en temps-réel sera appelé avec le descripteur de fichier dans le champ si_fd de siginfo_t. 
Consultez fcntl(2) pour plus d'informations.

Dans certains cas (par exemple, différents processus accédant à la même socket), la condition ayant déclenché 
le signal SIGIO peut avoir déjà disparu quand le processus réagit au signal. Si cela se produit, le processus 
devrait attendre à nouveau car Linux renverra ce signal ultérieurement.


Interfaces /proc
Les paramètres réseau de base des sockets sont accessibles en utilisant les fichiers du répertoire /proc/sys/net/core/.

rmem_default
    contient la taille en octets par défaut du tampon de réception. 
rmem_max
    contient la taille maximale en octets du tampon de réception qu'un utilisateur peut définir avec l'option SO_RCVBUF de la socket. 
wmem_default
    contient la taille en octets par défaut du tampon d'émission de la socket. 
wmem_max
    contient la taille maximale en octets du tampon d'émission qu'un utilisateur peut définir avec l'option SO_SNDBUF de la socket. 
message_cost et message_burst
    configurent le filtrage par jeton utilisé pour limiter la charge des messages d'avertissement dus aux événements réseau extérieurs. 
netdev_max_backlog
    contient le nombre maximal de paquets dans la file d'entrée globale. 
optmem_max
    contient la taille maximale par socket des données de service et des données de contrôle utilisateur comme les iovecs. 


Ioctls
Ces opérations sont accessibles en utilisant ioctl(2) :

error = ioctl(ip_socket, type_ioctl, &valeur_résultat);

SIOCGSTAMP
    Renvoie une structure timeval avec la date de réception du dernier paquet transmis à l'utilisateur. 
	Cela est utile pour des mesures précises du temps de cheminement. Consultez setitimer(2) pour une 
	description de la structure timeval. L'ioctl ne doit être utilisé que si l'option SO_TIMESTAMP de la 
	socket n'est pas définie. Sinon, la date du dernier paquet reçu quand SO_TIMESTAMP n'était pas définie 
	est renvoyée, provoquant un échec s'il n'existe pas de tels paquets (c'est-à-dire que ioctl(2) 
	renvoie -1 avec un errno défini à ENOENT). 
SIOCSPGRP
    Définit le processus ou le groupe de processus à qui envoyer les signaux SIGIO ou SIGURG lorsqu'une 
	opération d'entrée-sortie asynchrone est terminée ou si des données urgentes sont disponibles. 
	L'argument est un pointeur sur un pid_t. Si l'argument est positif, le signal est envoyé à ce processus. 
	S'il est négatif, le signal est envoyé au groupe de processus dont l'identifiant correspond à la valeur 
	absolue de l'argument. Un processus ne peut demander que l'émission vers lui-même ou son propre groupe, à 
	moins qu'il ait la capacité CAP_KILL ou un identifiant d'utilisateur effectif nul. 
FIOASYNC
    Change l'attribut O_ASYNC pour activer ou désactiver le mode d'entrée-sortie asynchrone de la socket. 
	Un mode d'entrée-sortie asynchrone signifie que le signal SIGIO ou le signal défini avec F_SETSIG est 
	envoyé quand un événement d'entrée-sortie se produit. 
    Le paramètre est un booléen entier. (Cette opération est synonyme de l'utilisation de fcntl(2) pour définir l'attribut O_ASYNC). 
SIOCGPGRP
    Lit le processus ou le groupe de processus auquel les signaux SIGIO ou SIGURG sont envoyés. 
	Zéro est obtenu quand aucun n'est défini. 


Opérations fcntl(2) valables :

FIOGETOWN
    Identique à l'ioctl(2) SIOCGPGRP. 
FIOSETOWN
    Identique à l'ioctl(2) SIOCSPGRP. 

VERSIONS
SO_BINDTODEVICE a été introduit dans Linux 2.0.30. SO_PASSCRED est une nouveauté de Linux 2.2. 
Les interfaces /proc ont été introduites dans Linux 2.2. SO_RCVTIMEO et SO_SNDTIMEO sont gérés depuis Linux 2.3.41. 
Auparavant, les délais d'attente étaient définis dans les protocoles et ne pouvaient être ni lus ni modifiés.

NOTES
Linux suppose que la moitié du tampon d'émission/réception est utilisé pour les structures internes du noyau. 
Ainsi les valeurs dans les fichiers /proc correspondants sont deux fois plus grandes que ce que l'on peut 
observer directement sur le câble.

Linux ne permettra la réutilisation des ports qu'avec l'option SO_REUSEADDR lorsque celle-ci sera définie 
à la fois par le précédent programme qui a effectué un bind(2) sur le port et par le programme qui veut 
réutiliser ce port. Ceci diffère de certaines implémentations (par exemple, sur FreeBSD) où seul le dernier 
programme doit définir l'option SO_REUSEADDR. Habituellement, cette différence est invisible, puisque, par exemple, 
un programme serveur est conçu pour toujours définir cette option. 

_______________________________________________________________________________________________________________________

SOCKET
	#include <sys/types.h> /* See NOTES */
	#include <sys/socket.h>

	int socket(int domain, int type, int protocol);

	The DOMAIN argument specifies a communication domain; this selects the protocol family
	which will be used for communication. These families are defined in <sys/socket.h>.
	The currently understood formats include: 
		AF_INET 	IPv4 Internet protocols 	ip(7)
		AF_INET6 	IPv6 Internet protocols 	ipv6(7)

	The socket has the indicated TYPE, which specifies the communication semantics.
	Currently defined types are: 
		SOCK_STREAM
			Provides sequenced, reliable, two-way, connection-based byte streams.
			An out-of-band data transmission mechanism may be supported. 
		SOCK_DGRAM
			Supports datagrams (connectionless, unreliable messages of a fixed maximum length). 
		SOCK_SEQPACKET
			Provides a sequenced, reliable, two-way connection-based data transmission path for
			datagrams of fixed maximum length; a consumer is required to read an entire packet
			with each input system call. 
		SOCK_RAW
			Provides raw network protocol access. 
		SOCK_RDM
			Provides a reliable datagram layer that does not guarantee ordering. 
		SOCK_PACKET
			Obsolete and should not be used in new programs; see packet(7).
	Some socket types may not be implemented by all protocol families;
	for example, SOCK_SEQPACKET is not implemented for AF_INET.

	Since Linux 2.6.27, the type argument serves a second purpose: in addition to specifying a
	socket type, it may include the bitwise OR of any of the following values,
	to modify the behavior of socket():
		SOCK_NONBLOCK
			Set the O_NONBLOCK file status flag on the new open file description.
			Using this flag saves extra calls to fcntl(2) to achieve the same result. 												<== <fcntl> autorised
		SOCK_CLOEXEC
			Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.
			See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.

	The protocol specifies a particular protocol to be used with the socket.
	Normally only a single protocol exists to support a particular socket type within a given protocol family,
	in which case protocol can be specified as 0. However, it is possible that many protocols may exist,
	in which case a particular protocol must be specified in this manner.
	The protocol number to use is specific to the 'communication domain' in which communication is to take place;
	see protocols(5).																												<-- protocol.txt
	See getprotoent(3) on how to map protocol name strings to protocol numbers.

	Sockets of type SOCK_STREAM are full-duplex byte streams, similar to pipes.\
		( https://web.maths.unsw.edu.au/~lafaye/CCM/transmission/transmode.htm )
	They do not preserve record boundaries. A stream socket must be in a connected state before any
	data may be sent or received on it. A connection to another socket is created with a connect(2) call. 							<== <connect> autorised
	Once connected, data may be transferred using read(2) and write(2) calls or some variant of the send(2) and recv(2) calls.		<== <recv> autorised
	When a session has been completed a close(2) may be performed.																	<== <close> autorised
	Out-of-band data may also be transmitted as described in send(2) and received as described in recv(2).							<== <send> autorised

	The communications protocols which implement a SOCK_STREAM ensure that data is not lost or duplicated.							<== reception control
	If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted
	within a reasonable length of time, then the connection is considered to be dead.
	When SO_KEEPALIVE is enabled on the socket the protocol checks in a protocol-specific manner if the other end is still alive.
	A SIGPIPE signal is raised if a process sends or receives on a broken stream;													<== signal
	this causes naive processes, which do not handle the signal, to exit.
	SOCK_SEQPACKET sockets employ the same system calls as SOCK_STREAM sockets.
	The only difference is that read(2) calls will return only the amount of data requested,
	and any data remaining in the arriving packet will be discarded.
	Also all message boundaries in incoming datagrams are preserved.

	SOCK_DGRAM and SOCK_RAW sockets allow sending of datagrams to correspondents named in sendto(2) calls.
	Datagrams are generally received with recvfrom(2), which returns the next datagram along with the address of its sender.

	SOCK_PACKET is an obsolete socket type to receive raw packets directly from the device driver. Use packet(7) instead.

	An fcntl(2) F_SETOWN operation can be used to specify a process or process group to receive a SIGURG signal 					<== <fcntl> autorised
	when the out-of-band data arrives or SIGPIPE signal when a SOCK_STREAM connection breaks unexpectedly. 							<== signal
	This operation may also be used to set the process or process group that receives the I/O and asynchronous notification 
	of I/O events via SIGIO. Using F_SETOWN is equivalent to an ioctl(2) call with the FIOSETOWN or SIOCSPGRP argument.

	When the network signals an error condition to the protocol module 
	(e.g., using a ICMP message for IP) the pending error flag is set for the socket. 
	The next operation on this socket will return the error code of the pending error. 
	For some protocols it is possible to enable a per-socket error queue to retrieve detailed information about the error; 
	see IP_RECVERR in ip(7).

	The operation of sockets is controlled by socket level options. These options are defined in <sys/socket.h>. 
	The functions setsockopt(2) and getsockopt(2) are used to set and get options, respectively.									<== <setsockopt> autorised
	
	Return Value
	On success, a file descriptor for the new socket is returned. On error, -1 is returned, and errno is set appropriately.
	Errors
		EACCES
			Permission to create a socket of the specified type and/or protocol is denied. 
		EAFNOSUPPORT
			The implementation does not support the specified address family. 
		EINVAL
			Unknown protocol, or protocol family not available. 
		EINVAL
			Invalid flags in type. 
		EMFILE
			Process file table overflow. 
		ENFILE
			The system limit on the total number of open files has been reached. 
		ENOBUFS or ENOMEM
			Insufficient memory is available. The socket cannot be created until sufficient resources are freed. 
		EPROTONOSUPPORT
			The protocol type or the specified protocol is not supported within this domain.

	Other errors may be generated by the underlying protocol modules.
	Conforming to
		4.4BSD, POSIX.1-2001.

	The SOCK_NONBLOCK and SOCK_CLOEXEC flags are Linux-specific.

	socket() appeared in 4.2BSD. 
	It is generally portable to/from non-BSD systems supporting clones of the BSD socket layer (including System V variants).

	Notes
	POSIX.1-2001 does not require the inclusion of <sys/types.h>, and this header file is not required on Linux. 
	However, some historical (BSD) implementations required this header file, 
	and portable applications are probably wise to include it.

	The manifest constants used under 4.x BSD for protocol families are PF_UNIX, PF_INET, 
	and so on, while AF_UNIX, AF_INET, and so on are used for address families. 
	However, already the BSD man page promises: "The protocol family generally is the same as the address family", 
	and subsequent standards use AF_* everywhere. 
_______________________________________________________________________________________________________________________

SETSOCKOPT
 setsockopt(2) - Lire et écrire les options d'une socket

#include <sys/types.h> /* Consultez NOTES */
#include <sys/socket.h>

int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);

DESCRIPTION
getsockopt() et setsockopt() manipulent les options associées à la socket à laquelle fait référence le descripteur 
de fichier sockfd. Ces options peuvent exister aux divers niveaux de protocole, et sont toujours présentes 
au niveau socket le plus élevé.

Quand on manipule une option d'une socket, il faut préciser le niveau où elle s'applique, et le nom de l'option. 
Au niveau de l'API des sockets, level prend la valeur SOL_SOCKET. Pour tous les autres niveaux, il faut fournir 
le numéro de protocole approprié. Par exemple, pour une option interprétée par le protocole TCP, level prendra le 
numéro du protocole TCP. Consultez getprotoent(3).																			<-- protocol.txt

Les paramètres optval et optlen sont utilisés pour déterminer les options pour setsockopt(). Pour getsockopt 
ils identifient un tampon dans lequel la valeur de l'option désirée doit être renvoyée. Pour getsockopt, 
optlen est un paramètre résultat, contenant initialement la taille du tampon pointé par optval, et rempli en retour 
pour indiquer la taille effective des valeurs renvoyées. Si aucune option n'est fournie ou renvoyée, optval peut être NULL.

optname et toute autre option sont passés sans interprétation au protocole approprié, pour qu'il l'interprète lui-même. 
Le fichier d'en-tête <sys/socket.h> contient les définitions pour le niveau socket. Les options pour les autres niveaux 
de protocole peuvent varier tant en format qu'en nom, consultez les pages de manuel de la section 7 pour plus d'informations.

La plupart des options au niveau socket utilisent un paramètre de type int pour optval. 
Pour setsockopt(), un paramètre non nul valide une option booléenne, et zéro l'invalide.									<== /!\

Pour une description des options disponibles consultez socket(7) et les pages correspondant au protocole concerné.
VALEUR RENVOYÉE
S'il réussit, cet appel système renvoie 0. S'il échoue, il renvoie -1 et remplit errno en conséquence.
ERREURS
	EBADF
		sockfd n'est pas un descripteur valable. 
	EFAULT
		optval pointe en dehors de l'espace d'adressage accessible. Avec getsockopt(), ceci peut s'appliquer également à optlen. 
	EINVAL
		optlen non valable pour setsockopt(). Dans certains cas cette erreur peut aussi se produire pour une valeur 
		non valable de optval (par exemple, pour l'option IP_ADD_MEMBERSHIP décrite dans ip(7)). 
	ENOPROTOOPT
		L'option est inconnue pour ce protocole. 
	ENOTSOCK
		Le paramètre sockfd est un fichier, pas une socket. 

CONFORMITÉ
SVr4, BSD 4.4 (ces appels système sont apparus dans BSD 4.2), POSIX.1-2001.
NOTES
POSIX.1-2001 ne requiert pas l'inclusion de <sys/types.h>, et cet en-tête n'est pas nécessaire sous Linux. 
Cependant, il doit être inclus sous certaines implémentations historiques (BSD), et les applications portables 
devraient probablement l'utiliser.

Le paramètre optlen de getsockopt() et setsockopt() est en fait un int [*] (et c'est ce qu'utilisent BSD 4.x, libc4 et libc5). 
Une certaine confusion POSIX a donné le socklen_t actuel, également utilisé par glibc. Pour plus de détails consultez accept(2). 

_______________________________________________________________________________________________________________________

GETSOCKNAME
