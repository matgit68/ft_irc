Lors d'acces a une machine, celle-ci se presente a travers une adresse IP permettant son identification.
De nombreux logiciels sont simultanement utilises sur la meme machine. Afin de preciser vers quel logiciel la communication
s'effectue, un socket est attribuer a un logiciel accedant au reseau depuis la machine, agissant comme identifiant supplementaire.
Une socket est simplement un moyen de désigner l’extrémité d’un canal de communication bidirectionnel, côté client ou serveur, 
en l’associant à un port.

Dans le cas du protocol TCP/IP (transmission control protocol / internet protocol)
Un numéro de port comprend 16 bits (0 à 65 535) et est associé à un protocole de transport donné
	(le port TCP n°i et le port UDP n°i )
le port TCP etablie une connexion prealable entre deux hotes, permettant des echange par cette liaison
le port UDP (user datagram protocol) n'est pas prealablement connecter, les echanges s'effectue alors message par message (non utilise pour nous).

le protocol TCP/IP permet alors
	- transmission bidirectionnelle par flot d'octet
	- garatie la fiabilite de l'echange des lors aue la liaison physique est cree
	- garantie un flux ordonne (ordre de reception identiaue a la rensmission)
	- Contrôle de flux. Permet au récepteur de limiter le débit d’émission en fonction de ses capacités de réception (entre récepteur et émetteur)
	- Contrôle de congestion. Permet d’agir sur le débit d’émission pour éviter la surcharge du réseau (entre réseau et émetteur)

SERVER SOCKET TCP
Un serveur en mode connecté doit attendre une nouvelle demande de connexion de la part d’un client, 
puis traiter la (ou les requêtes) envoyée(s) sur cette connexion par le client.
Les fonctions d’attente et de traitement sont séparées, pour permettre au serveur d’attendre de nouvelles demandes de 
connexion pendant qu’il traite des requêtes en cours.

La socket serveur est associée à un numéro de port connu des clients (par ex. port 80 pour un serveur web, etc.)
Chaque nouvelle connexion établie par le système d’exploitation du serveur est placée dans la file d’attente.
Si une demande de connexion arrive alors que la file est pleine, elle est rejetée (pourra être réessayée plus tard) -> voir connect()
La socket de communication est creer lors de la demande de connexion d'un client. Elle est associée au même numéro 
de port que la socket serveur, mais avec un descripteur différent

Etape 1 : créer une socket serveur TCP
					ServerSocket servSock = new ServerSocket();
Etape 2.a : associer la socket à une adresse IP et un numéro de port TCP locaux 
					int myPort = …
					InetSocketAddress ipAddrAndPort;
					ipAddrAndPort = new InetSocketAddress(myPort);
					servSock.bind(ipAddrAndPort, …);
Eape 2.b : définir la taille de la file d’attente pour les nouvelles connexions
					int backlogSize = …;
					…
					servSock.bind(ipAddrAndPort, backlogSize);
Etape 3a : permettre à l’application (côté serveur) de prendre connaissance d’une nouvelle connexion
					Socket sock;
					…
					sock = servSock.accept();					==> /!\ la primitive accept est bloquante (si la file est vide)
Etape 3b : obtention d’un canal de communication/dialogue par l’application (côté serveur)
					sock = servSock.accept();					==> au retour de accept() la connexion est supprimee de la file d'attente

CLIENT SOCKET TCP
Ici on connaît l’adresse d’un serveur et le numéro de port (TCP) d’une socket serveur sur celui-ci 
(un processus serveur est en attente sur ce port).

Etape 1 : créer une socket :
					Socket sock = new Socket();
Etape 1 bis : associer la socket à une adresse et/ou un numéro de port (locaux) particuliers (pas toujours necessaire a creer)
					InetSocketAddress localIpAddrAndPort = new InetSocketAddress(…);
					sock.bind(localIpAddrAndPort);
		Choisit un numéro de port libre dans une plage prédéfinie (ports dit « éphémères » ou « dynamiques »)
		Si la machine possède plusieurs adresses IP, associe à la socket l’adresse IP par défaut de la machine
Etape 2 : établir une connexion entre la socket client et le serveur
					InetSocketAddress serverIpAddrAndPort = new InetSocketAddress(…);
					sock.connect(serverIpAddrAndPort);			==> connect envoie une demande de connexion vers la socket serveur
																	(une exceptionIOException est levée en cas d’échec de la connexion)

ECHANGES 
Une fois la connexion établie, le client et le serveur disposent chacun d’un descripteur (pseudo-fichier) 
vers l’extrémité correspondante de la connexion (avec un flux d'entre et de sortie).
Le fonctionnement des flux est similaire au pipe FIFO :	entre client -> sortie server
														entre server -> sortie client
Une lecture sur un flux d’entrée peut être bloquante (si le tampon de réception ne contient pas de nouvelles données),
jusqu’à l’arrivée de nouvelles données envoyées par l’interlocuteur (ou jusqu’à la rupture de la connexion réseau).

VOIR LES SOCKET - command shell
	netstat -t -a --numeric-ports --numeric-hosts
	ss -t
'ss' Options utiles
	-a ou --all : permet d’afficher toutes les sockets existantes sur la machine (par défaut, seules les sockets connectées sont listées)
	-l ou --listening : affiche uniquement les sockets serveurs
	-p : affiche le pid du processus propriétaire d’une socket
	-e : permet de connaître l’utilisateur associé au processus propriétaire d’une socket
	-n ou --numeric : désactiver la résolution des noms de services
	-r ou --resolve : activer la résolution des noms de machines et de services

	port : 16 bits (0 à 65 535) = USHORT
			Les numéros de 0 à 1023 sont réservés, par convention, à des services spécifiques.
			Exemples (avec TCP) :
			7 : echo 	25 : SMTP (acheminement mail) 	443 : HTTPS (HTTP sécurisé)
			22 : SSH 	80 : HTTP (serveur web) 		465 : SMTPS (SMTP sécurisé)
_______________________________________________________________________________________________________________________

SOCKET
	#include <sys/types.h> /* See NOTES */
	#include <sys/socket.h>

	int socket(int domain, int type, int protocol);

	The DOMAIN argument specifies a communication domain; this selects the protocol family
	which will be used for communication. These families are defined in <sys/socket.h>.
	The currently understood formats include: 
		AF_INET 	IPv4 Internet protocols 	ip(7)
		AF_INET6 	IPv6 Internet protocols 	ipv6(7)

	The socket has the indicated TYPE, which specifies the communication semantics.
	Currently defined types are: 
		SOCK_STREAM
			Provides sequenced, reliable, two-way, connection-based byte streams.
			An out-of-band data transmission mechanism may be supported. 
		SOCK_DGRAM
			Supports datagrams (connectionless, unreliable messages of a fixed maximum length). 
		SOCK_SEQPACKET
			Provides a sequenced, reliable, two-way connection-based data transmission path for
			datagrams of fixed maximum length; a consumer is required to read an entire packet
			with each input system call. 
		SOCK_RAW
			Provides raw network protocol access. 
		SOCK_RDM
			Provides a reliable datagram layer that does not guarantee ordering. 
		SOCK_PACKET
			Obsolete and should not be used in new programs; see packet(7).
	Some socket types may not be implemented by all protocol families;
	for example, SOCK_SEQPACKET is not implemented for AF_INET.

	Since Linux 2.6.27, the type argument serves a second purpose: in addition to specifying a
	socket type, it may include the bitwise OR of any of the following values,
	to modify the behavior of socket():
		SOCK_NONBLOCK
			Set the O_NONBLOCK file status flag on the new open file description.
			Using this flag saves extra calls to fcntl(2) to achieve the same result. 												<== <fcntl> autorised
		SOCK_CLOEXEC
			Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.
			See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.

	The protocol specifies a particular protocol to be used with the socket.
	Normally only a single protocol exists to support a particular socket type within a given protocol family,
	in which case protocol can be specified as 0. However, it is possible that many protocols may exist,
	in which case a particular protocol must be specified in this manner.
	The protocol number to use is specific to the 'communication domain' in which communication is to take place;
	see protocols(5).																												<-- protocol.txt
	See getprotoent(3) on how to map protocol name strings to protocol numbers.

	Sockets of type SOCK_STREAM are full-duplex byte streams, similar to pipes.\
		( https://web.maths.unsw.edu.au/~lafaye/CCM/transmission/transmode.htm )
	They do not preserve record boundaries. A stream socket must be in a connected state before any
	data may be sent or received on it. A connection to another socket is created with a connect(2) call. 							<== <connect> autorised
	Once connected, data may be transferred using read(2) and write(2) calls or some variant of the send(2) and recv(2) calls.		<== <recv> autorised
	When a session has been completed a close(2) may be performed.																	<== <close> autorised
	Out-of-band data may also be transmitted as described in send(2) and received as described in recv(2).							<== <send> autorised

	The communications protocols which implement a SOCK_STREAM ensure that data is not lost or duplicated.							<== reception control
	If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted
	within a reasonable length of time, then the connection is considered to be dead.
	When SO_KEEPALIVE is enabled on the socket the protocol checks in a protocol-specific manner if the other end is still alive.
	A SIGPIPE signal is raised if a process sends or receives on a broken stream;													<== signal
	this causes naive processes, which do not handle the signal, to exit.
	SOCK_SEQPACKET sockets employ the same system calls as SOCK_STREAM sockets.
	The only difference is that read(2) calls will return only the amount of data requested,
	and any data remaining in the arriving packet will be discarded.
	Also all message boundaries in incoming datagrams are preserved.

	SOCK_DGRAM and SOCK_RAW sockets allow sending of datagrams to correspondents named in sendto(2) calls.
	Datagrams are generally received with recvfrom(2), which returns the next datagram along with the address of its sender.

	SOCK_PACKET is an obsolete socket type to receive raw packets directly from the device driver. Use packet(7) instead.

	An fcntl(2) F_SETOWN operation can be used to specify a process or process group to receive a SIGURG signal 					<== <fcntl> autorised
	when the out-of-band data arrives or SIGPIPE signal when a SOCK_STREAM connection breaks unexpectedly. 							<== signal
	This operation may also be used to set the process or process group that receives the I/O and asynchronous notification 
	of I/O events via SIGIO. Using F_SETOWN is equivalent to an ioctl(2) call with the FIOSETOWN or SIOCSPGRP argument.

	When the network signals an error condition to the protocol module 
	(e.g., using a ICMP message for IP) the pending error flag is set for the socket. 
	The next operation on this socket will return the error code of the pending error. 
	For some protocols it is possible to enable a per-socket error queue to retrieve detailed information about the error; 
	see IP_RECVERR in ip(7).

	The operation of sockets is controlled by socket level options. These options are defined in <sys/socket.h>. 
	The functions setsockopt(2) and getsockopt(2) are used to set and get options, respectively.									<== <setsockopt> autorised
	
	Return Value
	On success, a file descriptor for the new socket is returned. On error, -1 is returned, and errno is set appropriately.
	Errors
		EACCES
			Permission to create a socket of the specified type and/or protocol is denied. 
		EAFNOSUPPORT
			The implementation does not support the specified address family. 
		EINVAL
			Unknown protocol, or protocol family not available. 
		EINVAL
			Invalid flags in type. 
		EMFILE
			Process file table overflow. 
		ENFILE
			The system limit on the total number of open files has been reached. 
		ENOBUFS or ENOMEM
			Insufficient memory is available. The socket cannot be created until sufficient resources are freed. 
		EPROTONOSUPPORT
			The protocol type or the specified protocol is not supported within this domain.

	Other errors may be generated by the underlying protocol modules.
	Conforming to
		4.4BSD, POSIX.1-2001.

	The SOCK_NONBLOCK and SOCK_CLOEXEC flags are Linux-specific.

	socket() appeared in 4.2BSD. 
	It is generally portable to/from non-BSD systems supporting clones of the BSD socket layer (including System V variants).

	Notes
	POSIX.1-2001 does not require the inclusion of <sys/types.h>, and this header file is not required on Linux. 
	However, some historical (BSD) implementations required this header file, 
	and portable applications are probably wise to include it.

	The manifest constants used under 4.x BSD for protocol families are PF_UNIX, PF_INET, 
	and so on, while AF_UNIX, AF_INET, and so on are used for address families. 
	However, already the BSD man page promises: "The protocol family generally is the same as the address family", 
	and subsequent standards use AF_* everywhere. 
_______________________________________________________________________________________________________________________

SETSOCKOPT
 setsockopt(2) - Lire et écrire les options d'une socket

#include <sys/types.h> /* Consultez NOTES */
#include <sys/socket.h>

int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);

DESCRIPTION
getsockopt() et setsockopt() manipulent les options associées à la socket à laquelle fait référence le descripteur 
de fichier sockfd. Ces options peuvent exister aux divers niveaux de protocole, et sont toujours présentes 
au niveau socket le plus élevé.

Quand on manipule une option d'une socket, il faut préciser le niveau où elle s'applique, et le nom de l'option. 
Au niveau de l'API des sockets, level prend la valeur SOL_SOCKET. Pour tous les autres niveaux, il faut fournir 
le numéro de protocole approprié. Par exemple, pour une option interprétée par le protocole TCP, level prendra le 
numéro du protocole TCP. Consultez getprotoent(3).																			<-- protocol.txt

Les paramètres optval et optlen sont utilisés pour déterminer les options pour setsockopt(). Pour getsockopt 
ils identifient un tampon dans lequel la valeur de l'option désirée doit être renvoyée. Pour getsockopt, 
optlen est un paramètre résultat, contenant initialement la taille du tampon pointé par optval, et rempli en retour 
pour indiquer la taille effective des valeurs renvoyées. Si aucune option n'est fournie ou renvoyée, optval peut être NULL.

optname et toute autre option sont passés sans interprétation au protocole approprié, pour qu'il l'interprète lui-même. 
Le fichier d'en-tête <sys/socket.h> contient les définitions pour le niveau socket. Les options pour les autres niveaux 
de protocole peuvent varier tant en format qu'en nom, consultez les pages de manuel de la section 7 pour plus d'informations.

La plupart des options au niveau socket utilisent un paramètre de type int pour optval. 
Pour setsockopt(), un paramètre non nul valide une option booléenne, et zéro l'invalide.									<== /!\

Pour une description des options disponibles consultez socket(7) et les pages correspondant au protocole concerné.
VALEUR RENVOYÉE
S'il réussit, cet appel système renvoie 0. S'il échoue, il renvoie -1 et remplit errno en conséquence.
ERREURS
	EBADF
		sockfd n'est pas un descripteur valable. 
	EFAULT
		optval pointe en dehors de l'espace d'adressage accessible. Avec getsockopt(), ceci peut s'appliquer également à optlen. 
	EINVAL
		optlen non valable pour setsockopt(). Dans certains cas cette erreur peut aussi se produire pour une valeur 
		non valable de optval (par exemple, pour l'option IP_ADD_MEMBERSHIP décrite dans ip(7)). 
	ENOPROTOOPT
		L'option est inconnue pour ce protocole. 
	ENOTSOCK
		Le paramètre sockfd est un fichier, pas une socket. 

CONFORMITÉ
SVr4, BSD 4.4 (ces appels système sont apparus dans BSD 4.2), POSIX.1-2001.
NOTES
POSIX.1-2001 ne requiert pas l'inclusion de <sys/types.h>, et cet en-tête n'est pas nécessaire sous Linux. 
Cependant, il doit être inclus sous certaines implémentations historiques (BSD), et les applications portables 
devraient probablement l'utiliser.

Le paramètre optlen de getsockopt() et setsockopt() est en fait un int [*] (et c'est ce qu'utilisent BSD 4.x, libc4 et libc5). 
Une certaine confusion POSIX a donné le socklen_t actuel, également utilisé par glibc. Pour plus de détails consultez accept(2). 

_______________________________________________________________________________________________________________________

GETSOCKNAME
