Les Network protocols sont un ensemble de regles decrivant comment connecter des interfaces/appareils a travers un reseau
pour des echanges d'information faciles et securises. Les protocoles sont utilises comme langage commun pour les 
interfaces/appareils afin d'etablir la communication independamment des diferences de logiciel, matériels ou processus internes.

Les protocols de connexion se presentent comme un fichier ASCII, decrivant les variaitons 
"Defense Advanced Research Projects Agency" (DARPA) qui sont disponibles depuis le sous-systeme TCP/IP
Ils peuvent etre consultes en utilisant les nombres dans le fichier d'inclusion <include file> ARPA 
"Advanced Research Projects Agency" ou en les devinants. Ces nombres apparaissentdans le champ des protocols
de chaque IP header.

Des changements dur ce fichier entrainent des erreurs dans les paquets IP
"incorrect IP package..."
les protocols (nombre et nom correspondant) sonmt specifies par
       IANA (Internet Assigned Numbers Authority).
chaque ligne est formulee
              protocol number aliases ...
les champs sont separes par des espaces ou tabulations. les lignes vides sont ignorees
si une ligne contient un diese hash mark (#), le diese et la suite de la ligne est ignoree.

    les champs de description sont:
       protocol
              the native name for the protocol.  For example ip, tcp, or
              udp.

       number the official number for this protocol as it will appear
              within the IP header.

       aliases
              optional aliases for the protocol.

Ce fichier peut être distribué sur un réseau en utilisant un service de nommage network-wide 
	(like Yellow Pages/NIS or BIND/Hesiod).


FILES
       /etc/protocols
              The protocols definition file.

________________________________________________________________________________________________________________
ip(7) Implémentation Linux du protocole IPv4
SYNOPSIS
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h> /* surensemble des précédents */

tcp_socket = socket(AF_INET, SOCK_STREAM, 0);
udp_socket = socket(AF_INET, SOCK_DGRAM, 0);
raw_socket = socket(AF_INET, SOCK_RAW, protocole);


DESCRIPTION
Linux implémente le protocole internet (IP) version 4, décrit dans les RFC 791 et RFC 1122. ip contient une 
implémentation de la diffusion multiple niveau 2 conforme à la RFC 1112. Cette implémentation inclut un routeur IP 
comprenant un filtre de paquets.

L'interface de programmation est compatible avec les sockets BSD. Pour plus d'informations sur les sockets, 
consultez socket(7).

Une socket IP est créée en appelant la fonction socket(2) sous la forme socket(AF_INET, type_socket, protocole). 
Les types valables de sockets sont SOCK_STREAM pour ouvrir une socket tcp(7), SOCK_DGRAM pour ouvrir une 
socket udp(7), ou SOCK_RAW pour ouvrir une socket raw(7) permettant d'accéder directement au protocole IP. 
Le protocole indiqué est celui inscrit dans les en-têtes IP émis ou reçus. Les seules valeurs valables pour le 
protocole sont 0 et IPPROTO_TCP pour les sockets TCP, et 0 et IPPROTO_UDP pour les sockets UDP. Pour les sockets 
SOCK_RAW, un protocole IP IANA valable peut être indiqué, la RFC 1700 précise les numéros assignés.

Lorsqu'un processus veut recevoir de nouveaux paquets entrants ou des connexions, il doit attacher une socket à une 
adresse d'interface locale en utilisant bind(2). Une seule socket IP peut être attachée à une paire (adresse, port) 
locale donnée. Lorsque INADDR_ANY est indiqué au moment de l'attachement, la socket sera affectée à toutes les 
interfaces locales. Si listen(2) est appelée sur une socket non affectée, celle-ci est automatiquement attachée 
à un port libre aléatoire, avec l'adresse locale définie à INADDR_ANY. Si connect(2) est appelée sur une socket 
non affectée, celle-ci est automatiquement attachée à un port libre aléatoire ou un port partagé, avec l'adresse 
locale définie à INADDR_ANY.

L'adresse locale d'une socket TCP qui a été attachée est indisponible pendant quelques instants après sa fermeture, 
à moins que l'attribut SO_REUSEADDR ait été activé. Il faut être prudent en utilisant cet attribut, car il rend le 
protocole TCP moins fiable.


Format d'adresse
Une adresse de socket IP est définie comme la combinaison d'une adresse IP d'interface et d'un numéro de port. 
Le protocole IP de base ne fournit pas de numéro de port, ils sont implémentés par les protocoles de plus haut 
niveau comme udp(7) et tcp(7). Sur les sockets raw, le champ sin_port contient le protocole IP.

struct sockaddr_in {
    sa_family_t    sin_family; /* famille d'adresses : AF_INET */
    in_port_t      sin_port;   /* port dans l'ordre des
                                  octets réseau */
    struct in_addr sin_addr;   /* adresse Internet */
};

/* Adresse Internet */
struct in_addr {
    uint32_t       s_addr;     /* adresse dans l'ordre des
                                  octets réseau */
};

sin_family est toujours défini à AF_INET. C'est indispensable : sous Linux 2.2, la plupart des fonctions réseau 
renvoient EINVAL lorsque cette configuration manque. 

sin_port contient le numéro de port, dans l'ordre des octets du réseau. Les numéros de ports inférieurs à 1024 
sont dits privilégiés (ou parfois ports réservés). Seuls les processus privilégiés (à savoir ceux qui ont la 
capacité CAP_NET_BIND_SERVICE) peuvent appeler bind(2) pour ces sockets. Le protocole IPv4 en tant que tel 
n'a pas le concept de ports, ceux-ci étant seulement implémentés par des protocoles de plus haut niveau 
comme tcp(7) et udp(7).

sin_addr est l'adresse IP de l'hôte. Le membre s_addr de la structure in_addr contient l'adresse de l'interface 
de l'hôte, dans l'ordre des octets du réseau. in_addr doit se voir assigner l'une des valeurs INADDR_* 
(par exemple, INADDR_ANY) ou être manipulé au travers des fonctions de bibliothèque inet_aton(3), inet_addr(3), 
inet_makeaddr(3) ou directement par le système de résolution des noms (consultez gethostbyname(3)).


Les adresses IPv4 sont divisées en adresses de diffusions individuelle, générale et multiple. Les adresses de 			==> peut etre utile
diffusion individuelle décrivent une interface unique d'un hôte, les adresses de diffusion générale correspondent 
à tous les hôtes d'un réseau, et les adresses de diffusion multiple représentent tous les hôtes d'un groupe de 
diffusion multiple. Les datagrammes vers des adresses de diffusion générale ne peuvent être émis et reçus que si 
l'attribut de socket SO_BROADCAST est activé. Dans l'implémentation actuelle, les sockets orientées connexion ne 
sont autorisées que sur des adresses de diffusion individuelle.

Remarquez que l'adresse et le port sont toujours stockés dans l'ordre des octets du réseau. Cela signifie en 
particulier qu'il faut invoquer htons(3) sur le numéro attribué à un port. Toutes les fonctions de manipulation 		==> <htons()>
d'adresses et de ports de la bibliothèque standard fonctionnent dans l'ordre des octets.

Il existe plusieurs adresses particulières : INADDR_LOOPBACK (127.0.0.1) correspond toujours à l'hôte local à 
l’aide du périphérique loopback ; INADDR_ANY (0.0.0.0) signifie un attachement à n'importe quelle adresse ; 
INADDR_BROADCAST (255.255.255.255) signifie n'importe quel hôte et a le même effet sur l'attachement que 
INADDR_ANY, pour des raisons historiques.


Options de sockets
IP gère quelques options de sockets spécifiques au protocole, qui peuvent être définies avec setsockopt(2) et 		==> <setsockopt()>
consultées avec getsockopt(2). Le niveau d'option de sockets pour IP est IPPROTO_IP. Un attribut entier booléen 
est faux quand il vaut zéro, et vrai sinon.

IP_ADD_MEMBERSHIP (depuis Linux 1.2)
    Rejoint un groupe de diffusion multiple. L'argument est une structure ip_mreqn.

    struct ip_mreqn {
        struct in_addr imr_multiaddr; /* Adresse IP du groupe
                                         de diffusion multiple */
        struct in_addr imr_address;   /* Adresse IP de
                                         l'interface locale */
        int            imr_ifindex;   /* Numéro d'interface */
    };

    imr_multiaddr contient l'adresse du groupe de diffusion multiple que l'application veut rejoindre ou quitter. 
	Il doit s'agir d'une adresse de diffusion multiple valable (sinon setsockopt(2) échoue avec l'erreur EINVAL). 
	
	imr_address est l'adresse de l'interface locale avec laquelle le système doit joindre le groupe de diffusion 
	multiple. Si elle est égale à INADDR_ANY, une interface appropriée est choisie par le système. 
	
	imr_ifindex est le numéro de l'interface qui doit rejoindre ou quitter le groupe imr_multiaddr, ou zéro pour 
	indiquer n'importe quelle interface. 

    La structure ip_mreqn n'est disponible que depuis Linux 2.2. Pour la compatibilité, l'ancienne structure ip_mreq 
	(présente depuis Linux 1.2) est encore gérée ; elle ne diffère de ip_mreqn que par l'absence du membre imr_ifindex. 
	Uniquement valable avec setsockopt(2). 


IP_ADD_SOURCE_MEMBERSHIP (depuis Linux 2.4.22 et 2.5.68)
    Rejoint un groupe de diffusion multiple et autorise la réception de données uniquement depuis une source indiquée. 
	L'argument est une structure ip_mreq_source.

    struct ip_mreq_source {
        struct in_addr imr_multiaddr;  /* Adresse IP du groupe
                                          de diffusion multiple */
        struct in_addr imr_interface;  /* Adresse IP de
                                          l'interface locale */
        struct in_addr imr_sourceaddr; /* Adresse IP de la source
                                          de diffusion multiple */
    };

    La structure ip_mreq_source est similaire à ip_mreqn décrite sous IP_ADD_MEMBERSIP. 
	Le champ imr_multiaddr contient l'adresse du groupe de diffusion multiple que l'application veut rejoindre ou quitter.
	Le champ imr_interface est l'adresse de l'interface locale avec laquelle le système doit rejoindre le groupe de diffusion. 
	Le champ imr_sourceaddr contient l'adresse de la source depuis laquelle l'application veut recevoir des données. 
    Cette option peut être utilisée plusieurs fois pour autoriser la réception depuis plusieurs sources. 

IP_BLOCK_SOURCE (depuis Linux 2.4.22 / 2.5.68)
    Bloque la réception de données en diffusion multiple depuis une source spécifique pour un groupe donné. 
	Cela n'est possible qu'après que l'application s'est abonnée au groupe de diffusion multiple en utilisant 
	IP_ADD_MEMBERSHIP ou IP_ADD_SOURCE_MEMBERSHIP. 
    L'argument est une structure ip_mreq_source comme décrite pour IP_ADD_SOURCE_MEMBERSHIP. 
IP_DROP_MEMBERSHIP (depuis Linux 1.2)
    Quitte un groupe de diffusion multiple. L'argument est une structure ip_mreqn ou ip_mreq comme pour IP_ADD_MEMBERSHIP. 
IP_DROP_SOURCE_MEMBERSHIP (since Linux 2.4.22 et 2.5.68)
    Quitte un groupe spécifique à une source, c'est-à-dire arrêter de recevoir des données depuis une source donnée 
	pour un groupe de diffusion donné. Si l'application est abonnée à d'autres sources du même groupe, les données 
	des sources restantes seront toujours transmises. Pour couper la réception depuis toutes les sources, utilisez IP_LEAVE_GROUP. 
    L'argument est une structure ip_mreq_source comme décrite pour IP_ADD_SOURCE_MEMBERSHIP. 
IP_FREEBIND (depuis Linux 2.4)
    Si cette option est activée, cet attribut booléen permet l'attachement à une adresse IP non locale ou qui n'existe 
	pas (encore). Cela permet d'écouter sur une socket, sans que l'interface réseau sous-jacente ou l'adresse IP dynamique 
	indiquée ne soit opérationnelle au moment où l'application essaye de s'y attacher. Cette option est l'équivalent 
	spécifique à la socket de l'interface ip_nonlocal_bind de /proc décrite plus bas. 
IP_HDRINCL (depuis Linux 2.0)
    Si cette option est activée, l'utilisateur fournit un en-tête IP avant les données utilisateur. Cette option 
	n'est valable que pour les sockets SOCK_RAW. Consultez raw(7) pour plus de détails. Lorsque cet attribut 
	est activé, les valeurs définies pour IP_OPTIONS, IP_TTL et IP_TOS sont ignorées. 
IP_MSFILTER (depuis Linux 2.4.22 et 2.5.68)
    Cette option permet d'accéder à l'API de filtrage avancée. L'argument est une structure ip_msfilter.

    struct ip_msfilter {
        struct in_addr imsf_multiaddr; /* Adresse IP du groupe
                                          de diffusion multiple */
        struct in_addr imsf_interface; /* Adresse IP de
                                          l'interface locale */
        uint32_t       imsf_fmode;     /* Mode de filtrage */
    };
        uint32_t       imsf_numsrc;    /* Nombre de sources dans
                                          le tableau qui suit */
        struct in_addr imsf_slist[1];  /* Tableau des adresses
                                          sources */
    };

    Les deux macros MCAST_INCLUDE et MCAST_EXCLUDE permettent d'identifier le mode de filtrage. De plus, la macro IP_MSFILTER_SIZE(n) permet de déterminer la quantité de mémoire nécessaire pour stocker une structure ip_msfilter contenant n sources. 
    Pour une description complète du filtrage des sources de diffusion multiple, consultez la RFC 3376. 
IP_MTU (depuis Linux 2.2)
    Récupère la MTU du chemin actuellement déterminée pour la socket. Valable seulement quand la socket a été connectée. Renvoie un entier. Valable uniquement avec getsockopt(2). 
IP_MTU_DISCOVER (depuis Linux 2.2)
    Définit ou récupère la définition de recherche des MTU des chemins pour une socket. Lorsqu'elle est activée, Linux effectuera la recherche de la MTU d'un chemin conformément à la RFC 1191 sur les sockets SOCK_STREAM. Pour les sockets autres que SOCK_STREAM, IP_PMTUDISC_DO force l'activation de l'attribut interdisant la fragmentation sur tous les paquets sortants. L'utilisateur est responsable de l'empaquetage des données dans des blocs inférieurs à la MTU et doit s'assurer de la retransmission si besoin. Le noyau rejettera (avec l'erreur EMSGSIZE) les datagrammes qui sont plus gros que la MTU du chemin déterminée. IP_PMTUDISC_WANT fragmentera un datagramme si nécessaire d'après la MTU du chemin, ou activera l'attribut interdisant la fragmentation sinon.

    Les valeurs par défaut du système peuvent être basculées entre IP_PMTUDISC_WANT et IP_PMTUDISC_DONT en écrivant (respectivement des valeurs nulle ou non nulle) dans le fichier /proc/sys/net/ipv4/ip_no_pmtu_disc.
    Attributs MTU des chemins	Signification
    IP_PMTUDISC_WANT	utiliser une configuration par route
    IP_PMTUDISC_DONT	ne pas rechercher la MTU des chemins
    IP_PMTUDISC_DO	toujours chercher la MTU des chemins
    IP_PMTUDISC_PROBE	activer DF (« Don't Fragment », ne
    	pas fragmenter), mais ignore les
    	recherches de MTU des chemins

    Lorsque la recherche de la MTU des chemins est activée, le noyau garde automatiquement une trace des MTU des chemins par hôte de destination. Lorsqu'il est connecté à un correspondant spécifique avec connect(2), la MTU du chemin actuel déterminée peut être consultée en utilisant l'option IP_MTU de la socket (par exemple si une erreur EMSGSIZE se produit). La MTU des chemins peut changer au cours du temps. Pour les sockets sans connexion avec plusieurs destinations, la nouvelle MTU pour une destination donnée peut également être obtenue en utilisant la file d'erreur (consultez IP_RECVERR). Une nouvelle erreur sera mise en file pour chaque mise à jour de la MTU.

    Durant la recherche de la MTU, les paquets initiaux des sockets datagramme peuvent être perdus. Les applications utilisant UDP devraient le savoir, et les éviter dans leur stratégie de retransmission.

    Pour démarrer le processus de recherche de la MTU du chemin sur les sockets non connectées, il est possible de démarrer avec une grande taille de datagramme (jusqu'à 64 ko d'en-tête) et la diminuer au fur et à mesure des mises à jours de la MTU du chemin.

    Afin d'obtenir une estimation initiale de la MTU du chemin, connecte une socket datagramme à l'adresse de destination en utilisant connect(2) et consultez la MTU en appelant getsockopt(2) avec l'option IP_MTU.

    Il est possible d'implémenter la RFC 4821 pour les recherches de MTU avec des sockets SOCK_DGRAM ou SOCK_RAW en utilisant la valeur IP_PMTUDISC_PROBE (disponible depuis Linux 2.6.22). C'est aussi particulièrement utile pour les outils de diagnostic comme tracepath(8) qui veulent délibérément envoyer des paquets sonde plus larges que le MTU observé du chemin. 
IP_MULTICAST_ALL (depuis Linux 2.6.31)
    Définit la politique de distribution des messages multicast aux sockets attachés à l'adresse jocker INADDR_ANY. Ce paramètre est un booléen (par défaut à 1). Configuré à 1, la socket recevra les messages destinés à tous les groupes auxquels le système est abonné. Sinon, seuls seront distribués les messages destinés à des groupes auxquels la socket s'est explicitement abonné (par exemple en utilisant l'option IP_ADD_MEMBERSHIP). 
IP_MULTICAST_IF (depuis Linux 1.2)
    Définit le périphérique local pour une socket de diffusion multiple. L'argument est une structure ip_mreqn ou ip_mreq (depuis Linux 3.5), comme pour IP_ADD_MEMBERSHIP. 
    Lorsqu'une option de socket non valable est fournie, ENOPROTOOPT est renvoyée. 
IP_MULTICAST_LOOP (depuis Linux 1.2)
    Définit ou lit un entier booléen indiquant si les paquets de diffusion multiple doivent être renvoyés aux sockets locales. 
IP_MULTICAST_TTL (depuis Linux 1.2)
    Définit ou lit la valeur du champ Time-to-Live des paquets de diffusion multiple sortants sur cette socket. Il est très important pour les paquets de diffusion multiple de définir le TTL le plus petit possible. La valeur par défaut est 1, ce qui signifie que les paquets de diffusion multiple ne quittent pas le réseau local à moins que le programme de l'utilisateur ne le réclame explicitement. L'argument est un entier. 
IP_NODEFRAG (depuis Linux 2.6.36)
    Si activée (argument non nul), l'assemblage des paquets sortants est désactivé dans la couche netfilter. Cette option n'est valable que pour des sockets SOCK_RAW. L'argument est un entier. 
IP_OPTIONS (depuis Linux 2.0)
    Définit ou lit les options IP à envoyer avec chaque paquet sur cette socket. Les arguments sont un pointeur sur un tampon mémoire contenant les options et la longueur des options. L'appel à setsockopt(2) définit les options IP associées à une socket. La taille maximale des options pour IPv4 vaut 40 octets. Consultez la RFC 791 pour les options autorisées. Lorsque le paquet de connexion initiale d'une socket SOCK_STREAM contient des options IP, celles-ci seront automatiquement attribuées à la socket, avec les en-têtes de routage inversés. Les paquets entrants ne peuvent pas modifier les options après que la connexion a été établie. Le traitement des options de routage des paquets entrants est désactivé par défaut, et peut être validé en utilisant l'interface accept_source_route de /proc. Les autres options, comme les horodatages, sont toujours traitées. Pour les sockets datagramme, les options IP ne peuvent être définies que par l'utilisateur local. L'appel de getsockopt(2) avec IP_OPTIONS remplit le tampon fourni avec les options d'émission actuelles. 
IP_PKTINFO (depuis Linux 2.2)
    Fournit un message IP_PKTINFO de service, qui contient une structure pktinfo fournissant quelques informations sur le paquet entrant. Ça ne fonctionne que pour les sockets orientées datagramme. L'argument est un attribut indiquant à la socket si le message IP_PKTINFO doit être passé ou non. Le message lui-même ne peut être écrit ou lu que comme message de contrôle avec un paquet, en utilisant recvmsg(2) ou sendmsg(2). 

    struct in_pktinfo {
        unsigned int   ipi_ifindex;   /* Numéro d'interface     */
        struct in_addr ipi_spec_dst;  /* Adresse locale         */
        struct in_addr ipi_addr;      /* Adresse de destination */
    };

    ipi_ifindex est le numéro unique de l'interface sur laquelle le paquet a été reçu. ipi_spec_dst est l'adresse locale du paquet et ipi_addr est l'adresse de destination dans l'en-tête du paquet. Si IP_PKTINFO est passé à sendmsg(2) et ipi_spec_dst est différent de zéro, alors il sera utilisé comme adresse source pour la recherche dans la table de routage et pour définir les options de routage IP. Si ipi_ifindex est différent de zéro, l'adresse locale principale de l'interface indiquée par cet index remplace ipi_spec_dst pour la table de routage. 
IP_RECVERR (depuis Linux 2.2)
    Active le passage amélioré des messages d'erreur. Lorsque cette option est activée pour une socket datagramme, toutes les erreurs générées seront envoyées dans une file d'erreurs propre à la socket. Quand l'utilisateur détecte une erreur d'opération sur la socket, celle-ci peut être examinée en invoquant recvmsg(2) avec l'attribut MSG_ERRQUEUE défini. La structure sock_extended_err décrivant l'erreur sera passée comme message de service ayant le type IP_RECVERR et le niveau IPPROTO_IP. Cela permet une gestion d'erreur fiable sur les sockets non connectées. La partie comprenant les données reçues de la file d'erreurs contient le paquet ayant rencontré un problème. 
    Le message de contrôle IP_RECVERR contient une structure sock_extended_err : 

    #define SO_EE_ORIGIN_NONE    0
    #define SO_EE_ORIGIN_LOCAL   1
    #define SO_EE_ORIGIN_ICMP    2
    #define SO_EE_ORIGIN_ICMP6   3
    struct sock_extended_err {
        uint32_t ee_errno;   /* numéro d'erreur */
        uint8_t  ee_origin;  /* origine de l'erreur */
        uint8_t  ee_type;    /* type */
        uint8_t  ee_code;    /* code */
        uint8_t  ee_pad;
        uint32_t ee_info;    /* données supplémentaires */
        uint32_t ee_data;    /* autres données */
        /* Des données supplémentaires peuvent suivre */
    };
    struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);

    ee_errno contient le numéro de l'erreur errno mise en file. ee_origin est le code de l'origine de l'erreur. Les autres champs sont spécifiques au protocole. La macro SO_EE_OFFENDER renvoie un pointeur sur l'adresse d'un objet réseau d'où l'erreur provient, en prenant en argument un pointeur sur le message de service. Si cette adresse n'est pas disponible, le membre sa_family de la structure sockaddr contient AF_UNSPEC et les autres champs de sockaddr ne sont pas définis. 
    IP utilise la structure sock_extended_err comme suit : ee_origin contient SO_EE_ORIGIN_ICMP pour les erreurs reçues sous forme de paquet ICMP, ou SO_EE_ORIGIN_LOCAL pour les erreurs locales. Les valeurs inconnues doivent être ignorées. ee_type et ee_code sont définis à partir des champs type et code de l'en-tête ICMP. ee_info contient la MTU déterminée pour les erreurs EMSGSIZE. Le message contient aussi l'adresse sockaddr_in du nœud ayant causé l'erreur, qui peut être obtenu avec la macro SO_EE_OFFENDER. Le champ sin_family de l'adresse fournie par SO_EE_OFFENDER vaut AF_UNSPEC si la source était inconnue. Lorsque les erreurs proviennent du réseau, toutes les options IP (IP_OPTIONS, IP_TTL, etc.) valables pour la socket et contenues dans le paquet d'erreur sont transmises comme messages de contrôle. La charge du paquet causant l'erreur est renvoyée comme charge normale. TCP n'a pas de file d'erreurs ; MSG_ERRQUEUE n'est pas permis sur les sockets SOCK_STREAM. IP_RECVERR est valable pour TCP, mais toutes les erreurs sont renvoyées au retour des fonctions de socket ou par SO_ERROR. 
    Pour les sockets raw, IP_RECVERR active le passage de toutes les erreurs ICMP reçues à l'application, sinon les erreurs sont seulement renvoyées sur les sockets connectées. 
    Il s'agit d'un attribut booléen entier. IP_RECVERR est désactivée par défaut. 
IP_RECVOPTS (depuis Linux 2.2)
    Passe à l'utilisateur toutes les options IP entrantes dans un message de contrôle IP_OPTIONS. L'en-tête de routage et les autres options sont déjà remplies pour l'hôte local. Ce n'est pas géré pour les sockets SOCK_STREAM. 
IP_RECVORIGDSTADDR (depuis Linux 2.6.29)
    Cet attribut booléen active le message IP_ORIGDSTADDR de service dans recvmsg(2), dans lequel le noyau renvoie l'adresse de destination originale du datagramme en train d'être reçu. Le message de service contient une structure sockaddr_in. 
IP_RECVTOS (depuis Linux 2.2)
    Le message de service IP_TOS est passé avec les paquets entrants si cette option est activée. Elle contient un octet qui décrit le champ Type-Of-Service/Precedence de l'en-tête du paquet. Il s'agit d'un attribut entier booléen. 
IP_RECVTTL (depuis Linux 2.2)
    Lorsque cet attribut est défini, passe un message de contrôle IP_TTL avec le champ Time-to-Live du paquet reçu, sous forme d'octet. Ce n'est pas géré pour les sockets SOCK_STREAM. 
IP_RETOPTS (depuis Linux 2.2)
    Identique à IP_RECVOPTS, mais renvoie les options brutes non traitées, avec les options d'enregistrement des horodatages et du routage non remplies pour ce saut. 
IP_ROUTER_ALERT (depuis Linux 2.2)
    Passe tous les paquets à transférer avec l'option IP Router Alert activée sur cette socket. Ce n'est valable que pour les sockets raw, et sert par exemple pour les démons RSVP de l'espace utilisateur. Les paquets enregistrés ne sont pas redirigés par le noyau ; l'utilisateur est responsable de leurs envois. L'attachement des sockets est ignoré, et de tels paquets ne sont filtrés que par le protocole. Il s'agit d'un attribut entier. 
IP_TOS (depuis Linux 1.0)
    Définit ou récupère le champ Type-Of-Service (TOS) envoyé avec chaque paquet IP sortant de cette socket. Cela sert à gérer sur le réseau les priorités entre paquets. TOS est un octet. Quelques attributs TOS standards sont définis : IPTOS_LOWDELAY pour minimiser les délais pour le trafic interactif, IPTOS_THROUGHPUT pour optimiser le débit, IPTOS_RELIABILITY pour optimiser la fiabilité, IPTOS_MINCOST doit être utilisé pour les données de remplissage, quand la lenteur de transmission importe peu. Une de ces valeurs TOS au maximum peut être indiquée. Les autres bits ne sont pas valables et doivent être effacés. Linux envoie d'abord des datagrammes IPTOS_LOWDELAY par défaut, mais le comportement exact dépend de la politique configurée pour la file d'attente. Quelques niveaux de haute priorité peuvent réclamer les privilèges du superutilisateur (la capacité CAP_NET_ADMIN). La priorité peut aussi être définie d'une manière indépendante du protocole avec les options de socket (SOL_SOCKET, SO_PRIORITY) (consultez socket(7)). 
IP_TRANSPARENT (depuis Linux 2.6.24)
    Cet attribut booléen active le mandataire transparent sur cette socket. Cette option de socket permet à l'application appelante de s'attacher à une adresse IP non locale et de fonctionner à la fois comme un client et un serveur avec l'adresse extérieure comme point de terminaison local. Remarque : le routage doit être configuré pour que les paquets envoyés vers l'adresse extérieure soient routés via la boîte TProxy. Les privilèges du superutilisateur sont nécessaires pour l'activation de cette option de socket (la capacité CAP_NET_ADMIN). 
    Cette option doit également être configurée sur la socket redirigée pour la redirection TProxy avec la cible iptables TPROXY. 
IP_TTL (depuis Linux 1.0)
    Définit ou récupère le contenu actuel du champ Time-to-Live utilisé avec chaque paquet envoyé depuis cette socket. 
IP_UNBLOCK_SOURCE (depuis Linux 2.4.22 et 2.5.68)
    Débloque une source de diffusion multiple précédemment bloquée. Renvoie EADDRNOTAVAIL si la source indiquée n'était pas bloquée. 
    L'argument est une structure ip_mreq_source comme décrite pour IP_ADD_SOURCE_MEMBERSHIP. 

Interfaces /proc
Le protocole IP prend en charge une série d'interfaces /proc pour configurer certaines options globales. Les paramètres peuvent être accédés en lisant ou écrivant dans les fichiers du répertoire /proc/sys/net/ipv4/. Les interfaces décrites comme des booléens prennent une valeur entière. Celle-ci signifie que l'option correspondante est activée si elle est différente de zéro (« true »), et désactivée si elle vaut zéro (« false »).

ip_always_defrag (booléen ; depuis Linux 2.2.13)
    [Nouveauté des noyaux 2.2.13, dans les noyaux précédents, cette fonctionnalité était contrôlée lors de la compilation avec l'option CONFIG_IP_ALWAYS_DEFRAG. Cette option n'est plus présente dans les versions 2.4.x et suivantes.]

    Lorsque cet attribut booléen est activé (différent de zéro), les fragments entrants (morceaux de paquets IP obtenus quand un hôte entre l'origine et la destination a décidé que les paquets étaient trop grands et les a coupés en morceaux) seront réassemblés (défragmentés) avant d'être traités, même s'ils doivent être transférés.

    Cette option n'est à utiliser que pour un pare-feu qui est le seul lien d'entrée de votre réseau, ou un mandataire transparent. Il ne faut jamais l'utiliser pour un routeur ou un hôte normal. Sinon, les communications fragmentées peuvent être interrompues si les fragments circulent par différents liens. La défragmentation a également un coût mémoire et processeur important.

    C’est automagiquement activé lorsque le masquerading ou le mandataire transparent sont configurés. 
ip_autoconfig (depuis Linux 2.2 à 2.6.17)
    Non documenté. 
ip_default_ttl (entier ; défaut : 64 ; depuis Linux 2.2)
    Définit la valeur par défaut du champ Time-to-Live des paquets sortants. Cela peut être modifié individuellement pour chaque socket avec l'option IP_TTL. 
ip_dynaddr (booléen ; désactivé par défaut ; depuis Linux 2.0.31)
    Active la réécriture dynamique des adresses de socket et du masquerading lors des changements d'adresse d'interface. Cela sert pour les liaisons téléphoniques, avec des adresses IP changeantes. 0 signifie aucune réécriture, 1 les autorise, et 2 demande un mode bavard. 
ip_forward (booléen ; désactivé par défaut) ; depuis Linux 1.2
    Active le transfert IP avec un attribut booléen. Le transfert IP peut aussi être configuré interface par interface. 
ip_local_port_range (depuis Linux 2.2)
    Contient deux entiers qui définissent l'intervalle par défaut des ports locaux alloués aux sockets. L'allocation démarre avec le premier numéro et se termine avec le second. Cela ne doit pas entrer en conflit avec les ports utilisés pour le masquerading (bien que cela soit traité). De même, des choix arbitraires peuvent poser des problèmes avec certains pare-feu de filtrage par paquet qui font des suppositions sur les ports locaux utilisés. Le premier nombre doit être au moins supérieur à 1024 et de préférence à 4096 pour éviter les collisions avec les ports officiels et minimiser les problèmes de pare-feu. 
ip_no_pmtu_disc (booléen ; désactivé par défaut) ; depuis Linux 2.2
    Si activé, supprime la recherche par défaut des MTU des chemins pour les sockets TCP. La recherche de la MTU d'un chemin peut échouer avec des pare-feu mal configurés (qui rejettent tous les paquets ICMP) ou des interfaces mal configurées (par exemple, un lien point-à-point où les deux extrémités n'ont pas la même MTU). Il vaut mieux corriger le routeur défectueux que de supprimer globalement la recherche des MTU des chemins, car cette dernière option augmente les coûts du réseau. 
ip_nonlocal_bind (booléen ; désactivé par défaut ; depuis Linux 2.4)
    Si défini, permet aux processus de s'attacher avec bind(2) à des adresses IP non locales, ce qui peut être utile mais peut faire planter certaines applications. 
ip6frag_time (entier ; défaut : 30)
    Définit le temps en secondes de conservation d'un fragment IPv6 en mémoire. 
ip6frag_secret_interval (entier ; défaut : 600)
    Définit l'intervalle de régénération (en secondes) du secret de hachage (ou sa durée de vie) pour les fragments IPv6. 
ipfrag_high_thresh (entier), ipfrag_low_thresh (entier)
    Si le nombre de fragments IP en attente atteint ipfrag_high_thresh, la file est restreinte à ipfrag_low_thresh. Contient un entier avec le nombre d'octets. 
neigh/*
    Consultez arp(7). 

Ioctls
Tous les ioctls décrits dans socket(7) s'appliquent à ip.

Les ioctls pour configurer les paramètres génériques des périphériques sont décrits dans netdevice(7).
ERREURS

EACCES
    L'utilisateur a essayé de réaliser une opération sans avoir les permissions nécessaires. Cela inclut : l'envoi d'un paquet vers une adresse de diffusion générale sans avoir activé l'attribut SO_BROADCAST, l'envoi d'un paquet par une route interdite, la modification du paramétrage du pare-feu sans les privilèges du superutilisateur (la capacité CAP_NET_ADMIN) et l'attachement à un port privilégié sans les privilèges du superutilisateur (la capacité CAP_NET_BIND_SERVICE). 
EADDRINUSE
    Tentative d'attachement à une adresse déjà utilisée. 
EADDRNOTAVAIL
    Une interface inexistante a été demandée, ou l'adresse d'émission demandée n'était pas locale. 
EAGAIN
    L'opération sur une socket non bloquante devrait bloquer. 
EALREADY
    Une opération de connexion est déjà en cours sur une socket non bloquante. 
ECONNABORTED
    Une connexion a été fermée durant un appel à accept(2). 
EHOSTUNREACH
    Aucune table de routage valable ne correspond à l'adresse de destination. Cette erreur peut être due à un message ICMP d'un routeur distant ou pour la table de routage interne. 
EINVAL
    Un argument non valable a été fourni. Pour les opérations d'envoi, cela peut être causé par un envoi vers une route trou noir. 
EISCONN
    connect(2) a été appelée sur une socket déjà connectée. 
EMSGSIZE
    Un datagramme est plus grand que la MTU du chemin et ne peut pas être fragmenté. 
ENOBUFS, ENOMEM
    La mémoire libre est insuffisante. Cela signifie souvent que l'allocation mémoire est contrainte par les limites du tampon de socket, pas par la mémoire du système, mais ce n'est pas toujours le cas. 
ENOENT
    SIOCGSTAMP a été appelé sur une socket qu'aucun paquet n'a atteint. 
ENOPKG
    Un sous-système du noyau n'est pas configuré. 
ENOPROTOOPT et EOPNOTSUPP
    Passage d'une option de socket non valable. 
ENOTCONN
    L'opération n'est définie que sur une socket connectée, mais cette socket n'était pas connectée. 
EPERM
    L'utilisateur n'a pas la permission de définir une priorité haute, de changer la configuration ou d'envoyer des signaux au groupe ou au processus demandé. 
EPIPE
    La connexion a été fermée prématurément ou volontairement à l'autre extrémité. 
ESOCKTNOSUPPORT
    La socket n'est pas configurée ou un type de socket inconnu a été demandé. 

D'autres erreurs peuvent être déclenchées par les protocoles supérieurs. Consultez tcp(7), raw(7), udp(7) et socket(7).
NOTES
IP_FREEBIND, IP_MSFILTER, IP_MTU, IP_MTU_DISCOVER, IP_RECVORIGDSTADDR, IP_PKTINFO, IP_RECVERR, IP_ROUTER_ALERT et IP_TRANSPARENT sont spécifiques à Linux.

Soyez très prudents avec l'option SO_BROADCAST, elle n'est pas privilégiée sous Linux. Il est facile de surcharger un réseau avec des diffusions générales sans précaution. Pour les nouveaux protocoles applicatifs, il vaut mieux utiliser un groupe de diffusion multiple plutôt que la diffusion générale. Ce dernier est déconseillé.

Certaines autres implémentations des sockets BSD fournissent les options de socket IP_RCVDSTADDR et IP_RECVIF pour obtenir l'adresse de destination et l'interface des datagrammes reçus. Linux propose l'option IP_PKTINFO plus générale pour effectuer ce travail.

Certaines implémentations BSD des sockets fournissent également l'option IP_RECVTTL, mais un message de service ayant le type IP_RECVTTL est fourni avec le paquet entrant. C'est différent de l'option IP_TTL utilisée sous Linux.

L'utilisation du niveau des options de socket SOL_IP n'est pas portable, les empilages basés sur BSD utilisent le niveau IPPROTO_IP.
Compatibilité
Pour la compatibilité avec Linux 2.0, la syntaxe obsolète socket(AF_INET, SOCK_PACKET, protocole) est encore gérée pour ouvrir une socket packet(7). C’est déconseillé, et doit être remplacé par socket(AF_PACKET, SOCK_RAW, protocole). La principale différence est la nouvelle structure d'adresse sockaddr_ll pour les informations génériques de la couche de liaison à la place de l'ancienne sockaddr_pkt. 
________________________________________________________________________________________________________________

PROTOENT
The protoent structure is defined in <netdb.h> as follows:
	struct protoent {
		char  *p_name;       /* official protocol name */
		char **p_aliases;    /* alias list */
		int    p_proto;      /* protocol number */
	}
The members of the protoent structure are:
	p_name 
			The official name of the protocol.
	p_aliases
			A NULL-terminated list of alternative names for the
			protocol.
	p_proto
			The protocol number.
________________________________________________________________________________________________________________

getprotoent(3)          Library Functions Manual          getprotoent(3)

NAME

       getprotoent, getprotobyname, getprotobynumber, setprotoent,
       endprotoent - get protocol entry

LIBRARY

       Standard C library (libc, -lc)

SYNOPSIS

       #include <netdb.h>

       struct protoent *getprotoent(void);

       struct protoent *getprotobyname(const char *name);															<== <getprotobyname> autorised
       struct protoent *getprotobynumber(int proto);

       void setprotoent(int stayopen);
       void endprotoent(void);

DESCRIPTION

       The getprotoent() function reads the next entry from the
       protocols database (see protocols(5)) and returns a protoent
       structure containing the broken-out fields from the entry.  A
       connection is opened to the database if necessary.

       The getprotobyname() function returns a protoent structure for
       the entry from the database that matches the protocol name name.
       A connection is opened to the database if necessary.

       The getprotobynumber() function returns a protoent structure for
       the entry from the database that matches the protocol number
       number.  A connection is opened to the database if necessary.

       The setprotoent() function opens a connection to the database,
       and sets the next entry to the first entry.  If stayopen is
       nonzero, then the connection to the database will not be closed
       between calls to one of the getproto*() functions.

       The endprotoent() function closes the connection to the database.

RETURN VALUE

       The getprotoent(), getprotobyname(), and getprotobynumber()
       functions return a pointer to a statically allocated protoent
       structure, or a null pointer if an error occurs or the end of the
       file is reached.

FILES

       /etc/protocols
              protocol database file

ATTRIBUTES

       For an explanation of the terms used in this section, see
       attributes(7).
       ┌────────────────────┬───────────────┬──────────────────────────┐
       │ Interface          │ Attribute     │ Value                    │
       ├────────────────────┼───────────────┼──────────────────────────┤
       │ getprotoent()      │ Thread safety │ MT-Unsafe race:protoent  │
       │                    │               │ race:protoentbuf locale  │
       ├────────────────────┼───────────────┼──────────────────────────┤
       │ getprotobyname()   │ Thread safety │ MT-Unsafe                │
       │                    │               │ race:protobyname locale  │
       ├────────────────────┼───────────────┼──────────────────────────┤
       │ getprotobynumber() │ Thread safety │ MT-Unsafe                │
       │                    │               │ race:protobynumber       │
       │                    │               │ locale                   │
       ├────────────────────┼───────────────┼──────────────────────────┤
       │ setprotoent(),     │ Thread safety │ MT-Unsafe race:protoent  │
       │ endprotoent()      │               │ locale                   │
       └────────────────────┴───────────────┴──────────────────────────┘

       In the above table, protoent in race:protoent signifies that if
       any of the functions setprotoent(), getprotoent(), or
       endprotoent() are used in parallel in different threads of a
       program, then data races could occur.
